/**
  This file contains an 'Intel Peripheral Driver' and uniquely
  identified as "Intel Reference Module" and is
  licensed for Intel CPUs and chipsets under the terms of your
  license agreement with Intel or your vendor.  This file may
  be modified by the user, subject to additional terms of the
  license agreement
**/
/**
  Copyright (c) 2013-2016 Intel Corporation. All rights reserved
  This software and associated documentation (if any) is furnished
  under a license and may only be used or copied in accordance
  with the terms of the license. Except as permitted by such
  license, no part of this software or documentation may be
  reproduced, stored in a retrieval system, or transmitted in any
  form or by any means without the express written consent of
  Intel Corporation.

@file
  RmtCore.c

@brief
  Common core RMT algorithms.
**/
#ifdef SSA_FLAG

#define BSSA_LOGGING_LEVEL BSSA_LOGGING_INTERNAL_DEBUG_LEVEL

#if defined(__STUB__) || defined(HEADLESS_MRC)
#include <assert.h>
#endif // __STUB__

#include "ssabios.h"
#include "bssalogging.h"

#include "BitMask.h"
#include "ChkRetStat.h"
#include "InitPlatform.h" // must precede autogenerated_rmtconfig.h and autogenerated_rmtmetadata.h
#include "LogByteArrayAsHex.h"
#include "MarginParam.h"
#include "MemCfg.h"
#include "MemShmoo.h"
#include "MemPointTest.h"
#include "Platform.h"
#include "RMT.h" // for BSSA_TC_MAJOR_VER, BSSA_TC_MINOR_VER, etc.
#include "autogenerated_rmtcolumns.h"
#include "autogenerated_rmtconfig.h"
#include "autogenerated_rmtmetadata.h"
#include "RmtCore.h"

#ifndef ABS
  #define ABS(a) (((a) < 0) ? (-(a)) : (a))
#endif

// flag to enable BIOS-SSA debug messages
#define ENBL_BIOS_SSA_API_DEBUG_MSGS (0)

// flag to enable function trace debug messages
#define ENBL_FUNCTION_TRACE_DEBUG_MSGS (0)

// flag to enable verbose log messages
#define ENBL_VERBOSE_LOG_MSGS (0)

// flag to enable verbose error messages
#define ENBL_VERBOSE_ERROR_MSGS (0)

// flag to enable results debug messages
#define ENBL_RESULTS_DEBUG_LOG_MSGS (0)

// flag to enable lane plot debug messages
#define ENBL_LANE_PLOT_DEBUG_LOG_MSGS (0)

// flag to enable fixup debug messages
#define ENBL_FIXUP_DEBUG_LOG_MSGS (0)

// number of margin parameter group array elements
#define MARGIN_GROUP_ARRAY_ELE_CNT (4)

// number of margin parameter groups
#if SUPPORT_FOR_DDRT
#define MARGIN_GROUP_ARRAY_CNT (3)
#else
#define MARGIN_GROUP_ARRAY_CNT (2)
#endif // !SUPPORT_FOR_DDRT

// arrays of margin parameter groups
// NOTE: Any modification to the values in these arrays needs to be reflected
// in the LogRankmarginResults function's code.
GSM_GT MarginGroups[MARGIN_GROUP_ARRAY_CNT][MARGIN_GROUP_ARRAY_ELE_CNT] = \
{
  {
    RxDqsDelay,
    TxDqDelay,
    RxVref,
    TxVref,
  },
  {
    CmdAll,
    CmdVref,
    CtlAll,
    GsmGtMax
  },
#if SUPPORT_FOR_DDRT
  {
    EridDelay, // data for the first lane's EridDelay margin is stored in this index of the results
    GsmGtMax,  // data for the second lane's EridDelay margin is stored in this index of the results
    EridVref,  // data for the first lane's EridVref margin is stored in this index of the results
    GsmGtMax   // data for the second lane's EridVref margin is stored in this index of the results
  },
#endif
};

/**
  This function is used to get the bitmask value for the given margin group.
  The mask value is used for the *Mask test configuration values.

  @param[in]  MarginGroup  Margin parameter group.

  @retval Bitmask value
**/
UINT16 GetMarginGroupBitmask(
  GSM_GT MarginGroup)
{
  switch (MarginGroup) {
    case RxDqsDelay:
      return 1 << 0;
    case TxDqDelay:
      return 1 << 1;
    case RxVref:
      return 1 << 2;
    case TxVref:
      return 1 << 3;
    case CmdAll:
      return 1 << 4;
    case CmdVref:
      return 1 << 5;
    case CtlAll:
      return 1 << 6;
#if SUPPORT_FOR_DDRT
    case EridDelay:
      return 1 << 7;
    case EridVref:
      return 1 << 8;
#endif
    default:
      return 0;
  }
} // end function GetMarginGroupBitmask

/**
  This function is used to determine whether the given margin group is for
  command/address/control signals (as opposed to data signals).

  @param[in]  MarginGroup  Margin parameter group.

  @retval TRUE/FALSE
**/
static BOOLEAN IsCmdSignalMarginGroup(
  GSM_GT MarginGroup)
{
  switch (MarginGroup) {
    case CmdAll:
    case CtlAll:
    case CmdVref:
      return TRUE;
    default:
      return FALSE;
  }
} // end function IsCmdSignalMarginGroup

/**
  This function is used to get the step size associated with the given margin
  group.

  @param[in]  pRmtTestCfg  Pointer to RMT test configuration structure.
  @param[in]  IoLevel      I/O level.
  @param[in]  MarginGroup  Margin group.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 GetStepSize(
  IN CONST RMT_CONFIG *pRmtTestCfg,
  IN GSM_LT IoLevel,
  IN GSM_GT MarginGroup)
{
  UINT8 StepSize;

  if (IoLevel != DdrLevel) {
    // backside step size is always 1
    StepSize = 1;
  }
  else {
    switch (MarginGroup) {
    case RxDqsDelay:
      StepSize = pRmtTestCfg->RxDqsStepSize;
      break;
    case TxDqDelay:
      StepSize = pRmtTestCfg->TxDqStepSize;
      break;
    case RxVref:
      StepSize = pRmtTestCfg->RxVrefStepSize;
      break;
    case TxVref:
      StepSize = pRmtTestCfg->TxVrefStepSize;
      break;
    case CmdAll:
      StepSize = pRmtTestCfg->CmdAllStepSize;
      break;
    case CmdVref:
      StepSize = pRmtTestCfg->CmdVrefStepSize;
      break;
    case CtlAll:
      StepSize = pRmtTestCfg->CtlAllStepSize;
      break;
#if SUPPORT_FOR_DDRT
    case EridDelay:
      StepSize = pRmtTestCfg->EridDelayStepSize;
      break;
    case EridVref:
      StepSize = pRmtTestCfg->EridVrefStepSize;
      break;
#endif
    default:
      StepSize = 1;
    }
  }

  return StepSize;
} // end function GetStepSize

/**
  This function is used to initialize the given memory shmoo test configuration
  structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode  Lane shmoo stop mode.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitMemShmooCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_STOP_MODE LaneShmooStopMode)
{
  UINT16 MarginGroupBitmask;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.InitMemShmooCfg(LaneShmooStopMode=%u)\n", LaneShmooStopMode);
#endif

  MarginGroupBitmask = GetMarginGroupBitmask(pCoreTestData->CurrentMarginGroup);

  // initialize the memory shmoo configuration
  bssa_memset(&pCoreTestData->MemShmooCfg, 0, sizeof(pCoreTestData->MemShmooCfg));
  pCoreTestData->MemShmooCfg.IoLevel = pCoreTestData->CurrentIoLevel;
  pCoreTestData->MemShmooCfg.MarginGroup = pCoreTestData->CurrentMarginGroup;
  pCoreTestData->MemShmooCfg.IsDdrT = TRUE; // pCoreTestData->CurrentIsDdrT;

  pCoreTestData->MemShmooCfg.StepSize = GetStepSize(pCoreTestData->pTestCfg,
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);
  pCoreTestData->MemShmooCfg.IncrementalStepSize = 16;

  // RMT uses no guard band - emphasis is on speed
  pCoreTestData->MemShmooCfg.GuardBandSize = 0;

  if (pCoreTestData->pTestCfg->OptimizedShmooBitmask & MarginGroupBitmask) {
    pCoreTestData->MemShmooCfg.EnableOptimizedShmoo = TRUE;
  }

#if SUPPORT_FOR_DDRT
  // For the DDRT test, Cmd/CmdVref/Ctl test, we can't use binary search because it
  // could put the CPGC in a hung state
  if (HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg
#else
    &pCoreTestData->SelectMemPointTestCfg
#endif // !SUPPORT_FOR_EXTENDED_RANGE) 
    ))
  {
    if ((pCoreTestData->CurrentIoLevel == DdrLevel) &&
      IsCmdSignalMarginGroup(pCoreTestData->CurrentMarginGroup)) {
      pCoreTestData->MemShmooCfg.EnableOptimizedShmoo = FALSE;
    }
  }
#endif

  pCoreTestData->MemShmooCfg.LaneShmooStopMode = LaneShmooStopMode;
  pCoreTestData->MemShmooCfg.RankShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.ChannelShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.ControllerShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.SocketShmooStopMode = AllShmooStopMode;

  // This option will stop margin the channle that already statisfy stop condition. 
  // for example, during the Cmd margin with DDRT
  pCoreTestData->MemShmooCfg.StopChannelMarginOnStopCond = TRUE; 

  pCoreTestData->MemShmooCfg.EnableIncrementalStepping = \
    IsIncrementalSteppingRequired(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);

  if (IsJedecInitAfterErrRequired(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = TRUE;
    pCoreTestData->MemShmooCfg.DimmInitMode = Jedec;
  }
  else if (IsIoResetAfterErrRequired(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = TRUE;
    pCoreTestData->MemShmooCfg.DimmInitMode = IoReset;
  }
  else {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = FALSE;
  }

  pCoreTestData->MemShmooCfg.DisableInitMarginParam = TRUE;

#if SUPPORT_FOR_EXTENDED_RANGE
  pCoreTestData->MemShmooCfg.EnableExtendedRange = \
    pCoreTestData->pTestCfg->EnableExtendedRange;
#endif // SUPPORT_FOR_EXTENDED_RANGE

#if ENBL_VERBOSE_LOG_MSGS
  LogMemShmooTestCfg(SsaServicesHandle, &pCoreTestData->MemShmooCfg);
#endif
  if (ChkMemShmooTestCfg(SsaServicesHandle, &pCoreTestData->MemShmooCfg,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitMemShmooCfg

#if SUPPORT_FOR_EXTENDED_RANGE
/**
  This function is used to initialize the current memory point test
  configuration structure in the given core test data structure based on the
  select memory point test configuration structure, current rank
  combinations index in the given core test data structure, and (when testing
  serialization is selected) the given target socket, controller, and channel.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitCurrentMemPointTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  MEM_POINT_TEST_CONFIG *pMemPointTestCfg = \
    &pCoreTestData->CurrentMemPointTestCfg;
  MEM_POINT_TEST_CONFIG *pSelectMemPointTestCfg = \
    &pCoreTestData->SelectMemPointTestCfg;
  UINT8 Socket, Controller, Channel, Dimm, Rank, ByteGroup;
  BOOLEAN IsSocketToBeTested;
  BOOLEAN IsControllerToBeTested;
  BOOLEAN IsChannelToBeTested;
  UINT8 PairCount;
  DIMM_RANK_PAIR DimmRankPairs[2];
  RANK_TEST_MODE RankTestMode;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "InitCurrentMemPointTestCfg(CurrentRankCombinationIndex=%u)\n",
    pCoreTestData->CurrentRankCombinationIndex);
#endif

  // start by setting everything to 0
  bssa_memset(pMemPointTestCfg, 0, sizeof(*pMemPointTestCfg));

  // IF this is the frontside
  if (pCoreTestData->CurrentIoLevel == DdrLevel) {
#if SUPPORT_FOR_LRDIMM
    // IF the DIMMs are LRDIMMs
    if (pCoreTestData->MemCfg.IsLrDimms) {
      // only test between the first ranks of all DIMMs
      pMemPointTestCfg->TurnaroundsTestMode = OnlyInterDimmTurnarounds;
    }
#endif // SUPPORT_FOR_LRDIMM
  }
  // ELSE this is the backside
  else {
    // only test between the ranks within each DIMM
    pMemPointTestCfg->TurnaroundsTestMode = OnlyIntraDimmTurnarounds;
  }

  // start with the socket bitmask of selected devices
  pMemPointTestCfg->SocketBitmask = \
    pSelectMemPointTestCfg->SocketBitmask;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not to be tested THEN skip it
    if ((pMemPointTestCfg->SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    IsSocketToBeTested = FALSE;

    // start with the controller bitmask of selected devices
    pMemPointTestCfg->ControllerBitmasks[Socket] = \
      pSelectMemPointTestCfg->ControllerBitmasks[Socket];

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not to be tested THEN skip it
      if ((pMemPointTestCfg->ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      IsControllerToBeTested = FALSE;

      // start with the channel bitmask of selected devices
      pMemPointTestCfg->ChannelBitmasks[Socket][Controller] = \
        pSelectMemPointTestCfg->ChannelBitmasks[Socket][Controller];

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not to be tested THEN skip it
        if ((pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &
          (1 << Channel)) == 0) {
          continue;
        }

        // IF this rank combination is unique for this channel
        if (pCoreTestData->CurrentRankCombinationIndex <
          pCoreTestData->RankCombinationCnts[Socket][Controller][Channel]) {
          // add this channel to the channel validation mask
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] |= \
            1 << Channel;
        }

        IsChannelToBeTested = FALSE;

        RankTestMode = \
          pSelectMemPointTestCfg->RankTestModes[Socket][Controller][Channel];
        pMemPointTestCfg->RankTestModes[Socket][Controller][Channel] = \
          RankTestMode;

        PairCount = 2;
        if (GetCpgcPointTestDimmRanks(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          pSelectMemPointTestCfg, pCoreTestData->pCpgcPointTestData, Socket,
          Controller, Channel, &PairCount, &DimmRankPairs[0],
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // IF there's a DIMM A/rank A
        if (PairCount > 0) {
          Dimm = DimmRankPairs[0].Dimm;
          Rank = DimmRankPairs[0].Rank;

          // add them to the memory point test configuration DIMM A/rank A bitmasks
          pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] |= \
            1 << Dimm;
          pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] |= \
            1 << Rank;
        } // end if there's a DIMM A/rank A

        // IF we're testing rank-to-rank turnarounds and there's a DIMM B/rank B
        if ((RankTestMode == Turnarounds) && (PairCount > 1)) {
          Dimm = DimmRankPairs[1].Dimm;
          Rank = DimmRankPairs[1].Rank;

          // add them to the memory point test configuration DIMM B/rank B bitmasks
          pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] |= \
            1 << Dimm;
          pMemPointTestCfg->RankBBitmasks[Socket][Controller][Channel][Dimm] |= \
            1 << Rank;
        } // end if we're testing rank-to-rank turnarounds and there's a DIMM B/rank B

        // IF (we're testing singles AND there are DIMM A's to be tested) OR
        // (we're testing rank-to-rank turnarounds AND there are DIMM A's and DIMM B's to be tested)
        if (((RankTestMode == Singles) &&
          (pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] != 0)) ||
          ((RankTestMode == Turnarounds) &&
          (pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] != 0) &&
          (pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] != 0))) {
          IsSocketToBeTested = TRUE;
          IsControllerToBeTested = TRUE;
          IsChannelToBeTested = TRUE;
        }

        // IF it turns out that there were no ranks to test on this channel
        if (!IsChannelToBeTested) {
          // remove the channel
          pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
        }
      } // end for each channel

      // IF it turns out that there were no ranks to test on this controller
      if (!IsControllerToBeTested) {
        // remove the controller
        pMemPointTestCfg->ControllerBitmasks[Socket] &= ~(1 << Controller);
      }
    } // end for each controller

    // IF it turns out that there were no ranks to test on this socket
    if (!IsSocketToBeTested) {
      // remove the socket
      pMemPointTestCfg->SocketBitmask &= ~(1 << Socket);
    }
  } // end for each socket

  // FOR each controller:
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    // FOR each channel:
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      {
        // FOR each byte group:
        for (ByteGroup = 0;
          ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8);
          ByteGroup++) {
          pMemPointTestCfg->LaneValBitmasks[Controller][Channel][ByteGroup] = \
            0xFF;
        } // end for each byte group
      }

      pMemPointTestCfg->ChunkValBitmasks[Controller][Channel] = \
        ALL_CHUNKS_BITMASK;
    } // end for each channel
  } // end for each controller

#if ENBL_VERBOSE_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "CurrentMemPointTestCfg:\n");
  LogMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pMemPointTestCfg);
#endif
  if (ChkMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, pMemPointTestCfg, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitCurrentMemPointTestCfg
#endif // SUPPORT_FOR_EXTENDED_RANGE

/**
  This function is used to initialize the select memory point test
  configuration structure based on the given input parameters.

  The MarginGroup input parameter is to support the special case where the
  frontside CmdVref and CtlAll margining needs to support all ranks for LRDIMMs
  whereas all other margin parameters are only tested on the first rank.  Use a
  value of CmdVref for the special case and use a value of GsmGtMax for all
  other cases.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.
  @param[in]       MarginGroup        Margin group.
  @param[in]       RankCombination    Rank combination.
  @param[in]       IsDdrT             Flag indicating that DDR-T devices are being tested.
  @param[in]       InitAsAll          Flag indicating whether to initialize as all devices

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 InitSelectMemPointTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN GSM_LT IoLevel,
  IN GSM_GT MarginGroup,
  IN RANK_TEST_MODE RankTestMode,
  IN BOOLEAN IsDdrT,
  IN BOOLEAN InitAsAll)
{
  MEM_POINT_TEST_CONFIG* pMemPointTestCfg = \
    &pCoreTestData->SelectMemPointTestCfg;
  UINT8 Socket, Controller, Channel, Dimm, ByteGroup;
  BOOLEAN IsSocketToBeTested;
  BOOLEAN IsControllerToBeTested;
  BOOLEAN IsChannelToBeTested;
#if SUPPORT_FOR_DDRT
  MEMORY_TECHNOLOGY MemoryTech;
#endif // SUPPORT_FOR_DDRT

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "InitSelectMemPointTestCfg(IoLevel=%u RankTestMode=%u IsDdrT=%u InitAsAll=%u)\n",
    IoLevel, RankTestMode, IsDdrT, InitAsAll);
#endif

  // start by setting everything to 0
  bssa_memset(pMemPointTestCfg, 0, sizeof(*pMemPointTestCfg));

#if SUPPORT_FOR_TURNAROUNDS
  // set default value
  pMemPointTestCfg->TurnaroundsTestMode = AllRankTurnarounds;
  pMemPointTestCfg->TurnaroundsPairMode = pCoreTestData->TurnaroundsPairMode;

  // IF we're doing turnarounds
  if (RankTestMode == Turnarounds) {
    // IF this is the frontside
    if (IoLevel == DdrLevel) {
#if SUPPORT_FOR_LRDIMM
      // IF the DIMMs are LRDIMMs
      if (pCoreTestData->MemCfg.IsLrDimms) {
        // only test between the first ranks of all DIMMs
        pMemPointTestCfg->TurnaroundsTestMode = OnlyInterDimmTurnarounds;
      }
#endif // SUPPORT_FOR_LRDIMM
    }
    // ELSE this is the backside
    else {
      // only test between the ranks within each DIMM
      pMemPointTestCfg->TurnaroundsTestMode = OnlyIntraDimmTurnarounds;
    }
  } // end if we're doing turnarounds
#endif // SUPPORT_FOR_TURNAROUNDS

  // use the given socket bitmask and screen out unpopulated sockets
  pMemPointTestCfg->SocketBitmask = \
    pCoreTestData->pTestCfg->SocketBitmask & \
    pCoreTestData->SystemInfo.SocketBitMask;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not to be tested THEN skip it
    if ((pMemPointTestCfg->SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    IsSocketToBeTested = FALSE;

    // use the given controller bitmask and screen out unpopulated controllers
    pMemPointTestCfg->ControllerBitmasks[Socket] = \
      pCoreTestData->pTestCfg->ControllerBitmask & \
      pCoreTestData->MemCfg.ControllerBitmasks[Socket];

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not to be tested THEN skip it
      if ((pMemPointTestCfg->ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      IsControllerToBeTested = FALSE;

      // use the populated channels
      pMemPointTestCfg->ChannelBitmasks[Socket][Controller] = \
        pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] = \
        pCoreTestData->MemCfg.ChannelBitmasks[Socket][Controller];

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not to be tested THEN skip it
        if ((pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &
          (1 << Channel)) == 0) {
          continue;
        }

        IsChannelToBeTested = FALSE;

        pMemPointTestCfg->RankTestModes[Socket][Controller][Channel] = RankTestMode;

        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          // IF this DIMM is not populated THEN skip it
          if ((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] &
            (1 << Dimm)) == 0) {
            continue;
          }
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
          MemoryTech = pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm];
          // IF this is for backside non-Cmd/Ctl margining and non-LRDIMM, non-DDR-T
          // devices THEN skip it
          if ((IoLevel == LrbufLevel) &&
            (MarginGroup != CmdAll) &&
            (MarginGroup != CmdVref) &&
            (MarginGroup != CtlAll) &&
            !pCoreTestData->MemCfg.IsLrDimms && 
            (MemoryTech != SsaMemoryDdrT)) {   
              continue;
          }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

          pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] |= 1 << Dimm;

#if SUPPORT_FOR_TURNAROUNDS
          if (RankTestMode == Turnarounds) {
            pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] |= 1 << Dimm;
          }
#endif // SUPPORT_FOR_TURNAROUNDS

          IsSocketToBeTested = TRUE;
          IsControllerToBeTested = TRUE;
          IsChannelToBeTested = TRUE;

          // default is to test all ranks that are present
          pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] = \
            (1 << pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm]) - 1;

#if SUPPORT_FOR_LRDIMM
          // IF the DIMM is a LRDIMM and we're testing the frontside and the
          // margin parameter is neither CmdVref nor CtlAll
          if (pCoreTestData->MemCfg.IsLrDimms && (IoLevel == DdrLevel) &&
            (MarginGroup != CmdVref) && (MarginGroup != CtlAll)) {
            // only test the first rank on this DIMM
            pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] = 1;
          }
#endif // SUPPORT_FOR_LRDIMM
#if SUPPORT_FOR_DDRT
          // IF we're testing the frontside and the DIMM is a DDR-T
          if ((IoLevel == DdrLevel) && (MemoryTech == SsaMemoryDdrT)) {
            // only test the first rank on this DIMM
            pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] = 1;
          }
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
          if (RankTestMode == Turnarounds) {
            pMemPointTestCfg->RankBBitmasks[Socket][Controller][Channel][Dimm] = \
              pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm];
          }
#endif // SUPPORT_FOR_TURNAROUNDS
        } // end for each DIMM

#if SUPPORT_FOR_TURNAROUNDS
        // IF we're doing turnarounds and this channel can't do turnarounds
        if ((RankTestMode == Turnarounds) &&
          !CanChannelDoTurnarounds(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg, pMemPointTestCfg,
          IoLevel, Socket, Controller, Channel, IsDdrT)) {
          // remove the channel
          IsChannelToBeTested = FALSE;
        }
#endif // SUPPORT_FOR_TURNAROUNDS

        // IF it turns out that there were no ranks to test on this channel
        if (!IsChannelToBeTested) {
          // remove the channel
          pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
        }
      } // end for each channel

      // IF it turns out that there were no ranks to test on this controller
      if (pMemPointTestCfg->ChannelBitmasks[Socket][Controller] == 0) {
        // remove the controller
        pMemPointTestCfg->ControllerBitmasks[Socket] &= ~(1 << Controller);
      }
    } // end for each controller

    // IF it turns out that there were no ranks to test on this socket
    if (!IsSocketToBeTested) {
      // remove the socket
      pMemPointTestCfg->SocketBitmask &= ~(1 << Socket);
    }
  } // end for each socket

  // FOR each controller:
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    // FOR each channel:
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      // FOR each byte group:
      for (ByteGroup = 0; ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8); ByteGroup++) {
        pMemPointTestCfg->LaneValBitmasks[Controller][Channel][ByteGroup] = 0xFF;
      } // end for each byte group

      pMemPointTestCfg->ChunkValBitmasks[Controller][Channel] = ALL_CHUNKS_BITMASK;
    } // end for each channel
} // end for each controller

#if ENBL_VERBOSE_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "SelectMemPointTestCfg:\n");
  LogMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo, pMemPointTestCfg);
#endif
  if (ChkMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, pMemPointTestCfg, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitSelectMemPointTestCfg

/**
  This function is the margin parameter change handler function.

  This function conforms to the MARGIN_PARAM_CHG_HANDLER typedef in MemShmoo.h.

  @param[in, out]  pClientTestData   Pointer to client test data.
  @param[in]       IoLevel           I/O level.
  @param[in]       MarginGroup       Margin group.
  @param[in]       TestingOffset     Margin parameter offset being tested.
**/
static VOID MarginParamChgHandler(
  IN OUT VOID *pClientTestData,
  IN GSM_LT IoLevel,
  IN GSM_GT MarginGroup,
  IN INT16 TestingOffset)
{
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pClientTestData;

  pCoreTestData->TestingOffset = TestingOffset;
} // end function MarginParamChgHandler

/**
@brief
  This is the post-DIMM-initialization handler function.  The function will be
  called by the MemShmoo code immediately after a DIMM initialization is
  performed.

  This function conforms to the POST_DIMM_INIT_HANDLER function typedef
  published in MemShmoo.h.

  @param[in, out]  SsaServicesHandle      Pointer to SSA services.
  @param[in]       pSystemInfo            Pointer to system information structure.
  @param[in]       pMemCfg                Pointer to memory configuration structure.
  @param[in]       pMemPointTestCfg       Pointer to generic memory point test configuration structure.
  @param[in]       pClientTestCfg         Pointer to client test configuration structure.
  @param[in, out]  pClientTestData        Pointer to client test data structure.
  @param[in]       IsLastRankCombination  Flag indicating that this is the last rank combination.
  @param[out]      pTestStat              Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 PostDimmInitHandler(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST MRC_SYSTEM_INFO *pSystemInfo,
  IN CONST MEM_CFG *pMemCfg,
  IN CONST MEM_POINT_TEST_CONFIG *pMemPointTestCfg,
  IN CONST VOID *pClientTestCfg,
  IN OUT VOID *pClientTestData,
  IN BOOLEAN IsLastRankCombination,
  OUT TEST_STATUS *pTestStat)
{
  RMT_CONFIG* pTestCfg = (RMT_CONFIG*) pClientTestCfg;
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pClientTestData;
  BOOLEAN IsFirstCall, InitDqdbContent, IsLastCall;

  // clean up the CPGC point test
  IsLastCall = FALSE;
  CleanupCpgcPointTest(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg, IsLastCall,
    &pCoreTestData->pCpgcPointTestData);

  // re-initialize the CPGC engine
  IsFirstCall = FALSE;
  InitDqdbContent = FALSE;
  if (SetupCpgcPointTest(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pCoreTestData->pCpgcInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    RmtPointTestResultHandler, pCoreTestData, pCoreTestData->CurrentIoLevel,
    pCoreTestData->CurrentIsDdrT, pTestCfg->TestStatusLogLevel, IsFirstCall,
    InitDqdbContent, &pCoreTestData->pCpgcPointTestData, pTestStat)) {
    return 1;
  }

  // re-initialize the rank programming
  if (SetCpgcPointTestRankCombinationIndex(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    pCoreTestData->pCpgcPointTestData,
    pCoreTestData->CurrentRankCombinationIndex,
    TRUE, // need to update HW register setting
    pCoreTestData->pTestStat)) {
    return 1;
  }

  // IF we're currently in the binary search state
  if (GetInBinarySearchState(pCoreTestData->pMemShmooData)) {
    // restore binary search settings
    if (pCoreTestData->SetPointTestInBinarySearchState(SsaServicesHandle,
      &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
      &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
      pCoreTestData->pCpgcPointTestData, TRUE, pTestStat)) {
      return 1;
    }
  }

  return 0;
} // end function PostDimmInitHandler

/**
  This function is used to initialize the last pass margin status.

  @param[in, out]  pCoreTestData  Pointer to RMT core test data structure.
**/
static VOID InitMarginStatus(
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  bssa_memset(&pCoreTestData->LastPassLaneOffsets, 0, sizeof(pCoreTestData->LastPassLaneOffsets));
  bssa_memset(&pCoreTestData->LastPassFoundMasks, 0, sizeof(pCoreTestData->LastPassFoundMasks));

  // clear the margin parameter limits accumulator
  bssa_memset(&pCoreTestData->LimitOffsets, 0, sizeof(pCoreTestData->LimitOffsets));
} // end function InitMarginStatus

#if SUPPORT_FOR_EXTENDED_RANGE
/*
@brief
  This function is used to fixup extended range results.

  @param[in, out]  SsaServicesHandle   Pointer to SSA services.
  @param[in, out]  pCoreTestData       Pointer to core test data structure.
  @param[in]       ShmooDir            Shmoo direction.
  @param[in]       ResultType          Result type.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 FixupResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_DIRECTION ShmooDir,
  IN RMT_RESULT_TYPE ResultType)
{
  SSA_STATUS RetStat;
  UINT8 Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane;
  UINT8 LaneBitmasks[MAX_BUS_WIDTH / 8];
  UINT16 SettleDelay;
  INT16 MinOffset, MaxOffset;
  UINT16 StepUnit;
  UINT32 EleIdx;
  UINT8 ShmooDirIdx;
  UINT8 MarginGroupArrayIdx;
  UINT8 MarginGroupEleIdx = 0;
  BOOLEAN MarginGroupFound;
  UINT8 ByteGroup;
  RMT_RESULT_COLUMNS *pResultElement;
  UINT8 LimitOffset;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "FixupResults(ShmooDir=%u ResultType=%u MarginOffset=%u (%s)\n",
    ShmooDir, ResultType, pCoreTestData->CurrentMarginGroup,
    GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
#endif

  // find the MarginGroupArrayIdx and MarginGroupEleIdx for the given MarginGroup value
  MarginGroupFound = FALSE;
  for (MarginGroupArrayIdx = 0; MarginGroupArrayIdx < MARGIN_GROUP_ARRAY_CNT;
    MarginGroupArrayIdx++) {
    for (MarginGroupEleIdx = 0; MarginGroupEleIdx < MARGIN_GROUP_ARRAY_ELE_CNT;
      MarginGroupEleIdx++) {
      if (MarginGroups[MarginGroupArrayIdx][MarginGroupEleIdx] ==
        pCoreTestData->CurrentMarginGroup) {
        MarginGroupFound = TRUE;
        break;
      }
    }
    if (MarginGroupFound) {
      break;
    }
  }
  if (!MarginGroupFound || (MarginGroupEleIdx >= MARGIN_GROUP_ARRAY_ELE_CNT)) {
    ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__, pCoreTestData->pTestStat);
    return 1;
  }

  // FOR each result element:
  for (EleIdx = 0; EleIdx < pCoreTestData->ResultElementCount; EleIdx++) {
    pResultElement = &(pCoreTestData->pResultElements[EleIdx]);

    // IF this is not the type of result element we're looking for THEN skip it
    if ((pResultElement->Header.IoLevel != (UINT32) pCoreTestData->CurrentIoLevel) ||
      (pResultElement->Header.ResultType != (UINT32) ResultType)) {
      continue;
    }

    Socket = (UINT8) pResultElement->Header.Socket;
    Controller = (UINT8) pResultElement->Header.Controller;
    Channel = (UINT8) pResultElement->Header.Channel;
    DimmA = (UINT8) pResultElement->Header.DimmA;
    RankA = (UINT8) pResultElement->Header.RankA;
    DimmB = (UINT8) pResultElement->Header.DimmB;
    RankB = (UINT8) pResultElement->Header.RankB;
    Lane = (UINT8) pResultElement->Header.Lane;

#if ENBL_FIXUP_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "\n"
      "  EleIdx=%u Socket=%u Controller=%u Channel=%u ",
      EleIdx, Socket, Controller, Channel);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%d\n",
      DimmA, RankA, DimmB, RankB, Lane);
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

    // 
    if (ResultType == LaneRmtResultType) {
      // set the lane bitmasks to just this lane
      bssa_memset(LaneBitmasks, 0, sizeof(LaneBitmasks));

      ByteGroup = Lane / 8;

      LaneBitmasks[ByteGroup] = (1 << (Lane % 8));
    }
    else {
      bssa_memset(LaneBitmasks, 0, sizeof(LaneBitmasks));

      for (ByteGroup = 0; ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8);
        ByteGroup++) {
        LaneBitmasks[ByteGroup] = 0xFF;
      }

      for (Lane = 0; Lane < (pCoreTestData->SystemInfo.BusWidth % 8); Lane++) {
        LaneBitmasks[ByteGroup] |= 1 << Lane;
      }
    }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  GetMarginParamLimits(\n"
      "    Socket=%u Controller=%u Channel=%u Dimm=%u Rank=%u\n"
      "    LaneBitmasks=0x",
      Socket, Controller, Channel, DimmA, RankA);
    LogByteArrayAsHex(SsaServicesHandle, LaneBitmasks,
      (pCoreTestData->SystemInfo.BusWidth / 8));
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " IoLevel=%u (%s) MarginGroup=%u (%s)\n",
      pCoreTestData->CurrentIoLevel,
      GetIoLevelStr(pCoreTestData->CurrentIoLevel),
      pCoreTestData->CurrentMarginGroup,
      GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
#endif
    RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
      SsaServicesHandle, Socket, Controller, Channel, DimmA, RankA,
      LaneBitmasks, pCoreTestData->CurrentIoLevel,
      pCoreTestData->CurrentMarginGroup, &MinOffset, &MaxOffset, &SettleDelay,
      &StepUnit);
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
      pCoreTestData->pTestStat)) {
      return 1;
    }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "    MinOffset=%d MaxOffset=%d SettleDelay=%u\n",
      MinOffset, MaxOffset, SettleDelay);
#endif
    // IF the result is for rank-to-rank turnarounds and the ranks are different
    if ((ResultType == TurnaroundRmtResultType) &&
      ((DimmA != DimmB) || (RankA != RankB))) {
      INT16 MinOffsetB, MaxOffsetB;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  GetMarginParamLimits(\n"
        "    Socket=%u Controller=%u Channel=%u Dimm=%u Rank=%u\n"
        "    LaneBitmasks=0x",
        Socket, Controller, Channel, DimmB, RankB);
      LogByteArrayAsHex(SsaServicesHandle, LaneBitmasks,
        (pCoreTestData->SystemInfo.BusWidth / 8));
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        " IoLevel=%u (%s) MarginGroup=%u (%s)\n",
        pCoreTestData->CurrentIoLevel,
        GetIoLevelStr(pCoreTestData->CurrentIoLevel),
        pCoreTestData->CurrentMarginGroup,
        GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
        SsaServicesHandle, Socket, Controller, Channel, DimmB, RankB,
        LaneBitmasks, pCoreTestData->CurrentIoLevel,
        pCoreTestData->CurrentMarginGroup, &MinOffsetB, &MaxOffsetB,
        &SettleDelay, &StepUnit);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
        return 1;
      }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "    MinOffsetB=%d MaxOffsetB=%d SettleDelay=%u\n",
        MinOffsetB, MaxOffsetB, SettleDelay);
#endif
      // IF rank A's minimum offset is outside rank B's minimum offset THEN
      if (MinOffset < MinOffsetB) {
        // use rank B's value
        MinOffset = MinOffsetB;
      }

      // IF rank A's maximum offset is outside rank B's maximum offset THEN
      if (MaxOffset > MaxOffsetB) {
        // use rank B's value
        MaxOffset = MaxOffsetB;
      }
    } // end if the result is for rank-to-rank turnarounds and ...

    // FOR both shmoo directions:
    for (ShmooDirIdx = 0; ShmooDirIdx <= 1; ShmooDirIdx++) {
      // IF this shmoo direction doesn't match the given shmoo direction THEN skip it
      if (((ShmooDir == LoDirection) && (ShmooDirIdx != 0)) ||
        ((ShmooDir == HiDirection) && (ShmooDirIdx != 1))) {
        continue;
      }

      // IF the shmoo direction is the low side
      if (ShmooDirIdx == 0) {
        LimitOffset = (UINT8) ABS(MinOffset);
      }
      else {
        LimitOffset = (UINT8) MaxOffset;
      }

#if ENBL_FIXUP_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ShmooDirIdx=%u MarginOffset=%u LimitOffset=%u\n",
        ShmooDirIdx, pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

      // IF the corresponding margin value is above the limit value
      if (pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx] > LimitOffset) {
#if ENBL_FIXUP_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "Fixing up result Index=%u Socket=%u Controller=%u Channel=%u ",
          EleIdx, Socket, Controller, Channel);
        if (ResultType == TurnaroundRmtResultType) {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "DimmA=%u RankA=%u DimmB=%u RankB=%u:\n",
            DimmA, RankA, DimmB, RankB);
        }
        else {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "Dimm=%u Rank=%u", DimmA, RankA);

          if (ResultType == LaneRmtResultType) {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              " Lane=%u:\n", Lane);
          }
          else {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, ":\n");
          }
        }
        if (ShmooDir == 0) {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Offset=%u MinOffset=%u\n",
            pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
        }
        else {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Offset=%u MaxOffset=%u\n",
            pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
        }
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

        // use the limit value instead
        pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx] = LimitOffset;
      }
    } // end for both shmoo directions
  } // end for each result element

  return 0;
} // end function FixupResults
#endif // SUPPORT_FOR_EXTENDED_RANGE

/**
@brief
  This function performs JEDEC initializations at the end of the test to ensure
  the DIMMs are left in a functional state.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to core test data structure.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 CleanupJedecInit(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller;
#if SUPPORT_FOR_DDRT
  UINT8 Channel, Dimm;
#endif // SUPPORT_FOR_DDRT
  BOOLEAN IsLastRankCombination;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "CleanupJedecInit()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF the controller is not enabled for testing THEN skip it
      if (!IsControllerTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket, Controller)) {
        continue;
      }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  IoReset(Socket=%u Controller=%u)\n",
        Socket, Controller);
#endif
      SsaServicesHandle->SsaMemoryConfig->IoReset(SsaServicesHandle,
        Socket, Controller);
    } // end for each controller
  } // end for each socket

#if SUPPORT_FOR_DDRT
  // IF there are DDR-T devices
  if (GetHasDdrtDevices(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg)) {
    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF the socket is not enabled for testing THEN skip it
      if (!IsSocketTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket)) {
        continue;
      }

      // do an AEP IO reset if the dimm is AEP dimm.
      // FOR each controller:
      for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
        // FOR each channel:
        for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
          // IF the channel is not enabled for testing THEN skip it
          if (!IsChannelTestingEnabled(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
            &pCoreTestData->CurrentMemPointTestCfg,
#else
            &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
            Socket, Controller, Channel)) {
            continue;
          }

          // FOR each DIMM
          for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
            // IF this DIMM isn't DDR-T THEN skip it
            if (((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] & (1 << Dimm)) == 0) ||
              (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] != SsaMemoryDdrT)) {
              continue;
            }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_DDRT_DEBUG_LOG_MSGS
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  AepIoReset(Socket=%u Controller=%u Channel=%u Dimm=%u)\n",
              Socket, Controller, Channel, Dimm);
#endif
            SsaServicesHandle->SsaMemoryDdrtConfig->AepIoReset(
              SsaServicesHandle, Socket, Controller, Channel, Dimm);
          } // end for each DIMM
        } // end for each channel
      } // end for each controller

      // do FIFO train reset
#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_DDRT_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ResetAepFifoTrain(Socket=%u)\n", Socket);
#endif
      SsaServicesHandle->SsaMemoryDdrtConfig->ResetAepFifoTrain(
        SsaServicesHandle, Socket);
    } // end for each socket
  } // end if there are DDR-T devices present
#endif // SUPPORT_FOR_DDRT

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF the controller is not enabled for testing THEN skip it
      if (!IsControllerTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket, Controller)) {
        continue;
      }
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  JedecReset(Socket=%u Controller=%u)\n",
        Socket, Controller);
#endif
      SsaServicesHandle->SsaMemoryConfig->JedecReset(
        SsaServicesHandle, Socket, Controller);
    } // end for each controller
  } // end for each socket

  // restore the CPGC engine programming after JEDEC init
  IsLastRankCombination = TRUE;
  if (PostDimmInitHandler(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->pTestCfg, pCoreTestData, IsLastRankCombination,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function CleanupJedecInit

/**
  This function is used to run the Margin1D test.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle    Pointer to SSA services.
  @param[in, out]  pCoreTestData        Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode    Lane shmoo stop mode.
  @param[in]       ShmooDirCount        Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs           Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 RunRmtMargin1D(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_STOP_MODE LaneShmooStopMode,
  IN UINT8 ShmooDirCount,
  IN CONST SHMOO_DIRECTION *pShmooDirs)
{
  UINT8 ShmooDirIdx;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.RunRmtMargin1D(LaneShmooStopMode=%u)\n",
    LaneShmooStopMode);
#endif
#if SUPPORT_FOR_EXTENDED_RANGE
  if (InitCurrentMemPointTestCfg(SsaServicesHandle, pCoreTestData)) {
    return 1;
  }
#endif // SUPPORT_FOR_EXTENDED_RANGE

#ifdef __STUB__
  // confirm design assumption that DDR is 0 while DDRT is 1 in the RMT core test data
  // UINT8 LimitOffsets[MemTechMax][RmtShmooDirMax]; // 0: DDR; 1: DDRT. 
  assert(DDR == 0);
  assert(DDRT == 1);
#endif // __STUB__

  // initialize the shmoo test configuration
  if (InitMemShmooCfg(SsaServicesHandle, pCoreTestData, LaneShmooStopMode)) {
    return 1;
  }

  // setup the shmoo test
  if (SetupMemShmoo(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->GetPointTestDimmRanks,
    pCoreTestData->SetPointTestInBinarySearchState,
    pCoreTestData->RunPointTest, MarginParamChgHandler, NULL,
    PostDimmInitHandler, NULL, pCoreTestData->pTestCfg, pCoreTestData,
    pCoreTestData->pTestCfg->TestStatusLogLevel,
    &pCoreTestData->pMemShmooData, pCoreTestData->pTestStat)) {
    return 1;
  }

  // Save the Min/Max offset per memory technology to CoreTestData, and fill up the 
  // metadata later. The pMemShmooData would be invalid once CleanupMemShmoo() is called.
  pCoreTestData->LimitOffsets[DDR][LoRmtShmooDir] = (UINT8)ABS(GetMemShmooMinOffsetByMemoryTech(FALSE, pCoreTestData->pMemShmooData));
  pCoreTestData->LimitOffsets[DDR][HiRmtShmooDir] = (UINT8)ABS(GetMemShmooMaxOffsetByMemoryTech(FALSE, pCoreTestData->pMemShmooData));

#if SUPPORT_FOR_DDRT
  if (HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->CurrentMemPointTestCfg)) {
    pCoreTestData->LimitOffsets[DDRT][LoRmtShmooDir] = (UINT8)ABS(GetMemShmooMinOffsetByMemoryTech(TRUE, pCoreTestData->pMemShmooData));
    pCoreTestData->LimitOffsets[DDRT][HiRmtShmooDir] = (UINT8)ABS(GetMemShmooMaxOffsetByMemoryTech(TRUE, pCoreTestData->pMemShmooData));
  }
#endif // SUPPORT_FOR_DDRT

  // FOR all the given shmoo directions:
  for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
    // we need to run separate Margin1D tests for each shmoo direction so
    // that we can know the shmoo direction and process the results accordingly
    pCoreTestData->MemShmooCfg.ShmooDirection = \
      pCoreTestData->CurrentShmooDirection = \
      pShmooDirs[ShmooDirIdx];

    if (RunMargin1D(SsaServicesHandle, &pCoreTestData->SystemInfo,
      &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CurrentMemPointTestCfg,
#else
      &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CpgcPointTestCfg, pCoreTestData->pMemShmooData,
      pCoreTestData->pCpgcPointTestData, pCoreTestData->pTestStat)) {
      return 1;
    }

    // perform cleanup JEDEC initializations (if required)
    if (IsJedecInitAfterErrRequired( SsaServicesHandle,
      &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CurrentMemPointTestCfg,
#else
      &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
      pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
      if (CleanupJedecInit(SsaServicesHandle, pCoreTestData)) {
        return 1;
      }
    }
  } // end for all the given shmoo directions

  // clean up the shmoo test
  if (CleanupMemShmoo(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->pMemShmooData, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function RunRmtMargin1D

/**
  The function is used to get the next result element.  This function also
  zeros the result element content and increments the count of used result
  elements in the RMT core test data structure.

  @param[in, out]  SsaServicesHandle   Pointer to SSA services.
  @param[in, out]  pCoreTestData       Pointer to RMT core test data.
  @param[in]       DefaultMarginValue  Default value for the Margin field values.
  @param[out]      ppElement           Pointer to pointer to result element.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 GetNextResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT8 DefaultMarginValue,
  OUT RMT_RESULT_COLUMNS **ppElement)
{
  SSA_STATUS RetStat;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  GetNextResultElement()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->GetNextResultElement(
    SsaServicesHandle, ppElement);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  // IF this is the first result element:
  if (pCoreTestData->ResultElementCount == 0) {
    pCoreTestData->pResultElements = *ppElement;
  }

  pCoreTestData->ResultElementCount++;

  bssa_memset(&(*ppElement)->Header, 0, sizeof((*ppElement)->Header));
  bssa_memset(&(*ppElement)->Margin, DefaultMarginValue, sizeof((*ppElement)->Margin));

  return 0;
} // end function GetNextResultElement

/**
  This function is used to find the columnar result element associated with the
  given values.  If the element doesn't exist then NULL is returned.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         Result type.
  @param[in]       IoLevel            I/O level.
  @param[in]       IsDdrT             Flag indicating whether result is for DDR-T.
  @param[in]       Socket             Zero based CPU socket number.
  @param[in]       Controller         Zero based memory controller number.
  @param[in]       Channel            Zero based memory channel number.
  @param[in]       DimmA              Zero based first DIMM number.
  @param[in]       RankA              Zero based first DIMM number.
  @param[in]       DimmB              Zero based second DIMM number.
  @param[in]       RankB              Zero based second DIMM number.
  @param[in]       Lane               Zero based lane number.

  @retval  Pointer to the result element or NULL is the element doesn't exist.
**/
static RMT_RESULT_COLUMNS *FindResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType,
  IN GSM_LT IoLevel,
  IN BOOLEAN IsDdrT,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN UINT8 DimmA,
  IN UINT8 RankA,
  IN UINT8 DimmB,
  IN UINT8 RankB,
  IN UINT8 Lane)
{
  UINT32 EleIdx;
  RMT_RESULT_COLUMNS *pElement = NULL;
  BOOLEAN ElementFound = FALSE;

  // FOR each result element:
  for (EleIdx = 0; EleIdx < pCoreTestData->ResultElementCount; EleIdx++) {
    pElement = &pCoreTestData->pResultElements[EleIdx];

    // IF this is not the result element we're looking for THEN skip it
    if ((pElement->Header.ResultType != (UINT32) ResultType) ||
      (pElement->Header.IoLevel != (UINT32) IoLevel) ||
      (pElement->Header.IsDdrT != IsDdrT) ||
      (pElement->Header.Socket != Socket) ||
      (pElement->Header.Controller != Controller) ||
      (pElement->Header.Channel != Channel) ||
      (pElement->Header.DimmA != DimmA) ||
      (pElement->Header.RankA != RankA) ||
      (pElement->Header.DimmB != DimmB) ||
      (pElement->Header.RankB != RankB) ||
      (pElement->Header.Lane != Lane)) {
      continue;
    }

    ElementFound = TRUE;

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "EleIdx=%u ResultType=%u IoLevel=%u IsDdrT=%u Socket=%u Controller=%u",
      EleIdx, ResultType, IoLevel, IsDdrT, Socket, Controller);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u\n",
     Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif
    break;
  } // end for each result element

  // IF we didn't find an existing result element
  if (!ElementFound) {
    pElement = NULL;
  }

  return pElement;
} // end function FindResultElement

/**
  This function is used to get the columnar result element associated with the
  given values.  If there is no element then one will be allocated.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         Result type.
  @param[in]       IoLevel            I/O level.
  @param[in]       IsDdrT             Flag indicating whether result is for DDR-T.
  @param[in]       Socket             Zero based CPU socket number.
  @param[in]       Controller         Zero based memory controller number.
  @param[in]       Channel            Zero based memory channel number.
  @param[in]       DimmA              Zero based first DIMM number.
  @param[in]       RankA              Zero based first DIMM number.
  @param[in]       DimmB              Zero based second DIMM number.
  @param[in]       RankB              Zero based second DIMM number.
  @param[in]       Lane               Zero based lane number.
  @param[in]       DefaultMarginValue  Default value for the Margin field values.
  @param[out]      ppElement          Pointer to pointer to columnar result element.

  @retval  Nothing
**/
static UINT8 GetResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType,
  IN GSM_LT IoLevel,
  IN BOOLEAN IsDdrT,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN UINT8 DimmA,
  IN UINT8 RankA,
  IN UINT8 DimmB,
  IN UINT8 RankB,
  IN UINT8 Lane,
  IN UINT8 DefaultMarginValue,
  OUT RMT_RESULT_COLUMNS **ppElement)
{
#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.GetResultElement(ResultType=%u IoLevel=%u IsDdrT=%u",
    ResultType, IoLevel, IsDdrT);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    " Socket=%u Controller=%u Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u)\n",
    Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif

  *ppElement = FindResultElement(SsaServicesHandle, pCoreTestData, ResultType,
    IoLevel, IsDdrT, Socket, Controller, Channel, DimmA, RankA, DimmB, RankB,
    Lane);

  // IF we didn't find the specified result element
  if (*ppElement == NULL) {
    RMT_RESULT_ROW_HEADER *pHeader;

    if (GetNextResultElement(SsaServicesHandle, pCoreTestData,
      DefaultMarginValue, ppElement)) {
      return 1;
    }

    pCoreTestData->UsedResultEleCount++;

    // initialize the result element header
    pHeader = &(*ppElement)->Header;
    pHeader->ResultType = ResultType;
    pHeader->IoLevel = IoLevel;
    pHeader->IsDdrT = IsDdrT;
    pHeader->Socket = Socket;
    pHeader->Controller = Controller;
    pHeader->Channel = Channel;
    pHeader->DimmA = DimmA;
    pHeader->RankA = RankA;
    pHeader->DimmB = DimmB;
    pHeader->RankB = RankB;
    pHeader->Lane = Lane;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "UsedResultEleCount=%u ResultType=%u IoLevel=%u IsDdrT=%u",
      pCoreTestData->UsedResultEleCount, ResultType, IoLevel, IsDdrT);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " Socket=%u Controller=%u Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u\n",
      Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif
  } // end if we didn't find an existing result element

  return 0;
} // end function GetResultElement

/**
  This function is used to log rank margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static VOID LogRankMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN GSM_LT IoLevel)
{
  UINT8 Socket, Controller, Channel, Dimm, RankCount, Rank;
  BOOLEAN IsDdrT;
  CONST RMT_RESULT_COLUMNS *pElement0, *pElement1;
  BOOLEAN HeaderPrinted;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogRankMarginResults()\n");
#endif

#ifdef __STUB__
  assert(MarginGroups[0][0] == RxDqsDelay);
  assert(MarginGroups[0][1] == TxDqDelay);
  assert(MarginGroups[0][2] == RxVref);
  assert(MarginGroups[0][3] == TxVref);
  assert(MarginGroups[1][0] == CmdAll);
  assert(MarginGroups[1][1] == CmdVref);
  assert(MarginGroups[1][2] == CtlAll);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask & pCoreTestData->SystemInfo.SocketBitMask &
      (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask & pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

          // FOR each rank:
          for (Rank = 0; Rank < RankCount; Rank++) {
            pElement0 = FindResultElement(SsaServicesHandle, pCoreTestData,
              Rank0RmtResultType, IoLevel, IsDdrT, Socket, Controller,
              Channel, Dimm, Rank, 0, 0, 0);

            pElement1 = FindResultElement(SsaServicesHandle, pCoreTestData,
              Rank1RmtResultType, IoLevel, IsDdrT, Socket, Controller,
              Channel, Dimm, Rank, 0, 0, 0);

            // IF either result element was found
            if ((pElement0 != NULL) || (pElement1 != NULL)) {
              if (!HeaderPrinted) {
                HeaderPrinted = TRUE;

                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "IoLevel=%s\n", GetIoLevelStr(pCoreTestData->CurrentIoLevel));

                // print the table heading
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "Rank Margin\n");
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "             RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+  ");
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "Cmd-  Cmd+  CmdV-  CmdV+  Ctl-  Ctl+\n");
              }
            }

            if (pElement0 != NULL) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "N%u.C%u.D%u.R%u: %6d %6d %5d %5d %6d %6d %5d %5d ",
                Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank,
                (-1 * pElement0->Margin[0][LoDirection]), pElement0->Margin[0][HiDirection],
                (-1 * pElement0->Margin[2][LoDirection]), pElement0->Margin[2][HiDirection],
                (-1 * pElement0->Margin[1][LoDirection]), pElement0->Margin[1][HiDirection],
                (-1 * pElement0->Margin[3][LoDirection]), pElement0->Margin[3][HiDirection]);
            } // end if the Rank0RmtResultType result element was found

            // IF the Rank1RmtResultType result element was found
            if (pElement1 != NULL) {
              // IF the Rank0RmtResultType element wasn't found
              if (pElement0 == NULL) {
                // print asterisks to indicate that Rank0RmtResultType values wasn't tested
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "N%u.C%u.D%u.R%u:      *      *     *     *      *      *     *     * ",
                  Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank);
              }

              // IF this is for the frontside and the memory devices are
              // LRDIMMs and the rank is non-zero
              if ((IoLevel == DdrLevel) && pCoreTestData->MemCfg.IsLrDimms && (Rank != 0)) {
                // print asterisks to indicate that CmdAll wasn't tested
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "    *     * ");
              }
              else {
                // print CmdAll results
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "%5d %5d ",
                  (-1 * pElement1->Margin[0][LoDirection]), pElement1->Margin[0][HiDirection]);
              }

              // print CmdVref results
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "%6d %6d ",
                (-1 * pElement1->Margin[1][LoDirection]), pElement1->Margin[1][HiDirection]);

              // IF CtlAll margining is enabled
              if (pCoreTestData->pTestCfg->EnableCtlAllMargin) {
                // print CtlAll results
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "%5d %5d",
                  (-1 * pElement1->Margin[2][LoDirection]), pElement1->Margin[2][HiDirection]);
              }
              else {
                // print asterisks to indicate that CtlAll wasn't tested
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "    *     *");
              }
            }
            // ELSE the Rank1RmtResultType result element wasn't found
            else {
              // IF the Rank0RmtResultType element was found
              if (pElement0 != NULL) {
                // print asterisks to indicate that CmdAll, CmdVref, and CtlAll weren't tested
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "    *     *      *      *     *     *");
              }
            } // end else the Rank1RmtResultType result element wasn't found

            // IF either result element was found
            if ((pElement0 != NULL) || (pElement1 != NULL)) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
            }
          } // end for each rank
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogRankMarginResults

#if SUPPORT_FOR_DDRT
/**
  This function is used to log Early Read ID margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  Nothing
**/
static VOID LogEridMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  GSM_LT IoLevel = DdrLevel;
  UINT8 Socket, Controller, Channel, Dimm, Rank = 0, Lane;
  BOOLEAN IsDdrT = TRUE;
  CONST RMT_RESULT_COLUMNS *pElement;
  BOOLEAN HeaderPrinted;
  BOOLEAN RankDataFound;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogEridMarginResults()\n");
#endif

#ifdef __STUB__
  assert(MarginGroups[2][0] == EridDelay);
  //assert(MarginGroups[2][2] == EridVref);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          RankDataFound = FALSE;

          pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
            Rank2RmtResultType, IoLevel, IsDdrT, Socket, Controller,
            Channel, Dimm, Rank, 0, 0, 0);

          if (pElement != NULL) {
            RankDataFound = TRUE;

            if (!HeaderPrinted) {
              HeaderPrinted = TRUE;

              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "IoLevel=%s\n", GetIoLevelStr(pCoreTestData->CurrentIoLevel));

              // print the table heading
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "Early Read ID Margin\n");
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "             Delay- Delay+ Vref- Vref+\n");
            }

            // FOR each Early Read ID lane:
            for (Lane = 0; Lane < 2; Lane++) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "N%u.C%u.D%u.L%u: %6d %6d %5d %5d\n",
                Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Lane,
                (-1 * pElement->Margin[Lane][LoDirection]),
                pElement->Margin[Lane][HiDirection],
                (-1 * pElement->Margin[Lane + 2][LoDirection]),
                pElement->Margin[Lane + 2][HiDirection]);
            } // end for each Early Read ID lane
          } // end if the result element was found
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogEridMarginResults
#endif // SUPPORT_FOR_DDRT

/**
  This function is used to log lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static VOID LogLaneMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN GSM_LT IoLevel)
{
  UINT8 Socket, Controller, Channel, Dimm, RankCount, Rank, Lane;
  BOOLEAN IsDdrT;
  CONST RMT_RESULT_COLUMNS *pElement;
  BOOLEAN HeaderPrinted;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogLaneMarginResults()\n");
#endif

#ifdef __STUB__
  assert(MarginGroups[0][0] == RxDqsDelay);
  assert(MarginGroups[0][1] == TxDqDelay);
  assert(MarginGroups[0][2] == RxVref);
  assert(MarginGroups[0][3] == TxVref);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

          // FOR each rank:
          for (Rank = 0; Rank < RankCount; Rank++) {
            // FOR each lane:
            for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
              pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                Channel, Dimm, Rank, 0, 0, Lane);

              if (pElement != NULL) {
                if (!HeaderPrinted) {
                  HeaderPrinted = TRUE;

                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "IoLevel=%s\n", GetIoLevelStr(pCoreTestData->CurrentIoLevel));

                  // print the table heading
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "Lane Margin\n");
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "                 RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+\n");
                }

                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "N%u.C%u.D%u.R%u.L%02u: %6d %6d %5d %5d %6d %6d %5d %5d\n",
                  Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank, Lane,
                  (-1 * pElement->Margin[0][LoDirection]), pElement->Margin[0][HiDirection],
                  (-1 * pElement->Margin[2][LoDirection]), pElement->Margin[2][HiDirection],
                  (-1 * pElement->Margin[1][LoDirection]), pElement->Margin[1][HiDirection],
                  (-1 * pElement->Margin[3][LoDirection]), pElement->Margin[3][HiDirection]);
              } // end if the result element was found
            } // end for each lane
          } // end for each rank
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogLaneMarginResults

#if SUPPORT_FOR_TURNAROUNDS
/**
  This function is used to log rank-to-rank turnaround margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static VOID LogTurnaroundMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN GSM_LT IoLevel)
{
  UINT8 Socket, Controller, Channel;
  UINT8 DimmA, RankACount, RankA;
  UINT8 DimmB, RankBCount, RankB;
  BOOLEAN IsDdrT;
  CONST RMT_RESULT_COLUMNS *pElement;
  BOOLEAN HeaderPrinted;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogTurnaroundMarginResults()\n");
#endif

#ifdef __STUB__
  assert(MarginGroups[0][0] == RxDqsDelay);
  assert(MarginGroups[0][1] == TxDqDelay);
  assert(MarginGroups[0][2] == RxVref);
  assert(MarginGroups[0][3] == TxVref);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM-A:
        for (DimmA = 0; DimmA < MAX_DIMM_CNT; DimmA++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankACount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][DimmA];

          // FOR each rank-A:
          for (RankA = 0; RankA < RankACount; RankA++) {
            // FOR each DIMM-B:
            for (DimmB = 0; DimmB < MAX_DIMM_CNT; DimmB++) {
              // IF the DIMM B is not the same type as DIMM A then skip it
              if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] !=
                pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmB]) {
                continue;
              }

              RankBCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][DimmB];

              // FOR each rank-B:
              for (RankB = 0; RankB < RankACount; RankB++) {
                // IF the DIMMs and ranks are the same THEN skip it
                if ((DimmA == DimmB) && (RankA == RankB)) {
                  continue;
                }

                pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                  TurnaroundRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                  Channel, DimmA, RankA, DimmB, RankB, 0);

                if (pElement != NULL) {
                  if (!HeaderPrinted) {
                    HeaderPrinted = TRUE;

                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "IoLevel=%s\n", GetIoLevelStr(pCoreTestData->CurrentIoLevel));

                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "Turnaround Margin\n");
                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "                   RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+\n");
                  }

                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "N%u.C%u.D%u.R%u.D%u.R%u: %6d %6d %5d %5d %6d %6d %5d %5d\n",
                    Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), DimmA, RankA, DimmB, RankB,
                    (-1 * pElement->Margin[0][LoDirection]), pElement->Margin[0][HiDirection],
                    (-1 * pElement->Margin[2][LoDirection]), pElement->Margin[2][HiDirection],
                    (-1 * pElement->Margin[1][LoDirection]), pElement->Margin[1][HiDirection],
                    (-1 * pElement->Margin[3][LoDirection]), pElement->Margin[3][HiDirection]);
                } // end if the result element was found
              } // end for each rank-B
            } // end for each DIMM-B
          } // end for each rank-A
        } // end for each DIMM-A
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogTurnaroundMarginResults
#endif // SUPPORT_FOR_TURNAROUNDS

/**
  This function is used to plot lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 PlotLaneMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN BOOLEAN HasDdrtDevices)
{
  UINT8 i;
  GSM_LT IoLevel;
  GSM_GT MarginGroup;
  UINT8 MarginGroupIdx;
  UINT8 ByteGroup;
  UINT8 Socket, Controller, Channel, Dimm, RankCount, Rank, Lane;
  CONST RMT_RESULT_COLUMNS *pElement;
  INT16 MinOffset, MaxOffset;
  INT16 LoSideOffset, HiSideOffset;
  INT16 InnerLoSideOffset, OuterLoSideOffset;
  INT16 InnerHiSideOffset, OuterHiSideOffset;
  BOOLEAN LaneElementFound;
  BOOLEAN IsDdrT;
  UINT8 StepSize;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.PlotLaneMarginResults(HasDdrtDevices=%u)\n", HasDdrtDevices);
#endif

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  assert(DdrLevel == 0);
  assert(LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (IoLevel = DdrLevel; IoLevel <= LrbufLevel; IoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << IoLevel)) == 0) {
      continue;
    }

    // IF the I/O level is the backside and there are no devices with a
    // backside THEN skip it
    if ((IoLevel == LrbufLevel) &&
      (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
      !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices)) {
      continue;
    }
#else
  {
    IoLevel = 0;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

    // FOR each margin group:
    for (i = 0; i < MARGIN_GROUP_ARRAY_ELE_CNT; i++) {
      MarginGroup = MarginGroups[0][i];

      if (MarginGroup == GsmGtMax) {
        continue;
      }

#ifdef __STUB__
      assert(MarginGroups[0][0] == RxDqsDelay);
      assert(MarginGroups[0][1] == TxDqDelay);
      assert(MarginGroups[0][2] == RxVref);
      assert(MarginGroups[0][3] == TxVref);
#endif // __STUB__
      switch (MarginGroup) {
      case RxDqsDelay:
        MarginGroupIdx = 0;
        break;
      case TxDqDelay:
        MarginGroupIdx = 1;
        break;
      case RxVref:
        MarginGroupIdx = 2;
        break;
      case TxVref:
        MarginGroupIdx = 3;
        break;
      default:
        ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__,
          pCoreTestData->pTestStat);
        return 1;
      }

      StepSize = GetStepSize(pCoreTestData->pTestCfg, IoLevel, MarginGroup);

      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // IF this socket is not configured to be tested THEN skip it
        if ((pCoreTestData->pTestCfg->SocketBitmask &
          pCoreTestData->SystemInfo.SocketBitMask &
          (1 << Socket)) == 0) {
          continue;
        }

        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // IF this controller is not configured to be tested THEN skip it
          if ((pCoreTestData->pTestCfg->ControllerBitmask &
            pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
            (1 << Controller)) == 0) {
            continue;
          }

          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            // IF this channel is not present THEN skip it
            if ((pCoreTestData->MemCfg.ChannelBitmasks[Socket][Controller] &
              (1 << Channel)) == 0) {
              continue;
            }

            // FOR each DIMM:
            for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
              // IF this DIMM is not present THEN skip it
              if ((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] &
                (1 << Dimm)) == 0) {
                  continue;
              }
#if SUPPORT_FOR_DDRT
              if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] ==
                SsaMemoryDdrT) {
                  IsDdrT = TRUE;
              }
              else
#endif // SUPPORT_FOR_DDRT
              {
                IsDdrT = FALSE;
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
                // IF the I/O level is the backside and this device has no
                // backside THEN skip it
                if ((IoLevel == LrbufLevel) && !pCoreTestData->MemCfg.IsLrDimms &&
                  (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] != SsaMemoryDdrT)) {
                  continue;
                }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              }
              // get the margin parameter limits
              pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                ParamLimits0ResultType, IoLevel, IsDdrT, 0, 0, 0, 0, 0, 0, 0, 0);

              if (pElement == NULL) {
                ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__,
                  pCoreTestData->pTestStat);
                return 1;
              }

              MinOffset = 0 - (INT16) pElement->Margin[MarginGroupIdx][LoDirection];
              MaxOffset = (INT16) pElement->Margin[MarginGroupIdx][HiDirection];

              RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

              // FOR each rank:
              for (Rank = 0; Rank < RankCount; Rank++) {
                LaneElementFound = FALSE;

                // get the range of the high and low side offsets
                InnerLoSideOffset = -512;
                OuterLoSideOffset = 0;
                InnerHiSideOffset = 512;
                OuterHiSideOffset = 0;

                // FOR each lane:
                for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
                  pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                    LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                    Channel, Dimm, Rank, 0, 0, Lane);

                  if (pElement != NULL) {
                    LaneElementFound = TRUE;

                    // get the low side margin offset
                    LoSideOffset = 0 - (INT16) pElement->Margin[MarginGroupIdx][LoDirection];
                    HiSideOffset = (INT16) pElement->Margin[MarginGroupIdx][HiDirection];

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "Lane=%d LoSideOffset=%d HiSideOffset=%d\n",
                      Lane, LoSideOffset, HiSideOffset);
#endif

                    if (LoSideOffset > InnerLoSideOffset) {
                      InnerLoSideOffset = LoSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                        "  InnerLoSideOffset=%d\n", InnerLoSideOffset);
#endif
                    }

                    if (LoSideOffset < OuterLoSideOffset) {
                      OuterLoSideOffset = LoSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                        "  OuterLoSideOffset=%d\n", OuterLoSideOffset);
#endif
                    }

                    if (HiSideOffset < InnerHiSideOffset) {
                      InnerHiSideOffset = HiSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                        "  InnerHiSideOffset=%d\n", InnerHiSideOffset);
#endif
                    }

                    if (HiSideOffset > OuterHiSideOffset) {
                      OuterHiSideOffset = HiSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                        "  OuterHiSideOffset=%d\n", OuterHiSideOffset);
#endif
                    }
                  } // end if the result element was found
                } // end for each lane

                // IF there were no lane element entries for this rank THEN skip it
                if (!LaneElementFound) {
                  continue;
                }

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "MinOffset=%d MaxOffset=%d StepSize=%u\n",
                  MinOffset, MaxOffset, StepSize);
#endif

                // IF there's room below the lowest offset found
                if ((OuterLoSideOffset - StepSize) > MinOffset) {
                  // add a row that shows all lanes failing
                  OuterLoSideOffset -= StepSize;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "  OuterLoSideOffset=%d\n", OuterLoSideOffset);
#endif
                }

                // IF there's room above the highest offset found
                if ((OuterHiSideOffset + StepSize) < MaxOffset) {
                  // add a row that shows all lanes failing
                  OuterHiSideOffset += StepSize;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "  OuterHiSideOffset=%d\n", OuterHiSideOffset);
#endif
                }

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "OuterLoSideOffset=%d InnerLoSideOffset=%d InnerHiSideOffset=%d OuterHiSideOffset=%d\n",
                  OuterLoSideOffset, InnerLoSideOffset, InnerHiSideOffset, OuterHiSideOffset);
#endif
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Per bit IoLevel=%s MarginGroup=%s margin for N%u.C%u.D%u.R%u\n",
                  GetIoLevelStr(IoLevel), GetMarginGroupStr(MarginGroup),
                  Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank);
                // print column header
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "     0------7 8-----15");
                for (ByteGroup = 2; ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8); ByteGroup++) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    " %2u----%2u", (ByteGroup * 8), (((ByteGroup + 1) * 8) - 1));
                }
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n");

                // FOR each offset on the high side (from outermost to innermost+1)
                for (HiSideOffset = OuterHiSideOffset; HiSideOffset > InnerHiSideOffset; HiSideOffset--) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "%4d", HiSideOffset);

                  // FOR each lane:
                  for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
                    if ((Lane % 8) == 0) {
                      // insert space between byte groups
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, " ");
                    }

                    pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                      LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                      Channel, Dimm, Rank, 0, 0, Lane);

                    if (pElement != NULL) {
                      // IF the high side first-fail offset is inside the
                      // current offset OR the degenerative case where the
                      // inner offset is the minimum value
                      if ((pElement->Margin[MarginGroupIdx][HiDirection] < HiSideOffset) ||
                        (OuterHiSideOffset == 0)) {
                        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "*");
                      }
                      else {
                        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, " ");
                      }
                    } // end if the result element was found
                  } // end for each lane

                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
                } // end for each offset on the high side

                // FOR each offset on the low side (from innermost+1 to outermost)
                for (LoSideOffset = (InnerLoSideOffset - 1); LoSideOffset >= OuterLoSideOffset; LoSideOffset--) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "%4d", LoSideOffset);

                  // FOR each lane:
                  for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
                    if ((Lane % 8) == 0) {
                      // insert space between byte groups
                      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, " ");
                    }

                    pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                      LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                      Channel, Dimm, Rank, 0, 0, Lane);

                    if (pElement != NULL) {
                      // IF the low side first-fail offset is inside the current offset
                      if ((0 - (INT16) pElement->Margin[MarginGroupIdx][LoDirection]) > LoSideOffset) {
                        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "*");
                      }
                      else {
                        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, " ");
                      }
                    } // end if the result element was found
                  } // end for each lane

                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
                } // end for each offset on the low side
              } // end for each rank
            } // end for each DIMM
          } // end for each channel
        } // end for each controller
      } // end for each socket
    } // end for each margin group
  } // end for each I/O level

  return 0;
} // end function PlotLaneMarginResults

/**
  This function is used to report margin parameter limit results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data structure.
  @param[in]       ResultType         Result element type.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportParamLimitsResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType)
{
  RMT_RESULT_COLUMNS *pElement;
  UINT8 ShmooDir;
  MEM_TECH DdrOrDdrT;

#if SUPPORT_FOR_DDRT
  UINT8 Index;
#endif // SUPPORT_FOR_DDRT

  // Since we run DDR4 and DDRT test together, we need to report the limits of both DDR4 and DDRT
  for (DdrOrDdrT = 0; DdrOrDdrT <=1; DdrOrDdrT++)
  {
    if ((DdrOrDdrT == DDRT) && !HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
      &pCoreTestData->MemCfg, &pCoreTestData->CurrentMemPointTestCfg)){
      continue;
    }
    
    // ParamLimits2ResultType is for ERID, it is invalid for DDR
    if ((DdrOrDdrT == DDR) && (ResultType == ParamLimits2ResultType)){
      continue;
    }

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "RmtCore.ReportParamLimitsResults(ResultType=%u CurrentMarginGroupSubIndex=%u IsDdrT=%u)\n",
      ResultType, pCoreTestData->CurrentMarginGroupSubIndex, IsDdrT);
#endif

    if (GetResultElement(SsaServicesHandle, pCoreTestData, ResultType,
      pCoreTestData->CurrentIoLevel, DdrOrDdrT, 0, 0, 0, 0, 0,
      0, 0, 0, 0, &pElement)) {
      return 1;
    }

    // FOR each shmoo direction:
    for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
      // save the offset limits which are positive number.
      // Compare the new value to existing value, update to save the max value as iterating ranks.
      if (pCoreTestData->LimitOffsets[DdrOrDdrT][ShmooDir] > pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]) {
        pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
          pCoreTestData->LimitOffsets[DdrOrDdrT][ShmooDir];
      }

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ShmooDir=%u Offset=%u\n",
        ShmooDir, pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif

#if SUPPORT_FOR_DDRT
      // IF this is for Early Read ID margins
      if (ResultType == ParamLimits2ResultType) {
        Index = pCoreTestData->CurrentMarginGroupSubIndex + 1;

        // make sure the index is in range
        if (Index >= (sizeof(pElement->Margin) / sizeof(pElement->Margin[0]))) {
          ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__, pCoreTestData->pTestStat);
          return 1;
        }

        // copy the value in the second lane position as well
        pElement->Margin[Index][ShmooDir] = pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir];
      }
#endif // SUPPORT_FOR_DDRT
    } // end for each shmoo direction
  } // end of DDR and DDRT

  return 0;
} // end function ReportParamLimitsResults

/**
  This function is used to report Early Read ID margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportEridMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Dimm, Rank, Lane, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportEridMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;
  
        // IsDdrT field is always TRUE for ERID result
        if (GetResultElement(SsaServicesHandle, pCoreTestData,
          Rank2RmtResultType, pCoreTestData->CurrentIoLevel,
          TRUE, Socket, Controller, Channel, Dimm,
          Rank, 0, 0, 0, 0, &pElement)) {
          return 1;
        }

        // FOR each lane:
        for (Lane = 0; Lane < 2; Lane++) {
          // FOR each shmoo direction:
          for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
            // save the last pass offsets
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex + Lane][ShmooDir] = \
              pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  Socket=%u Controller=%u Channel=%u Lane=%u ShmooDir=%u Offset=%u\n",
              Socket, Controller, Channel, Lane, ShmooDir,
              pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif
          } // end for each shmoo direction
        } // end for each lane
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportEridMarginResults

/**
  This function is used to report lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportLaneMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Dimm, Rank, Lane, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  BOOLEAN IsDdrT;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportLaneMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because 
        // we test DDR and DDRT together. 
        // We need to base on the socket, control, dimm to determine the IsDdrT field. 
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }

        // FOR each lane:
        for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
          if (GetResultElement(SsaServicesHandle, pCoreTestData,
            LaneRmtResultType, pCoreTestData->CurrentIoLevel,
            IsDdrT, Socket, Controller, Channel, Dimm,
            Rank, 0, 0, Lane, 0, &pElement)) {
            return 1;
          }

          // FOR each shmoo direction:
          for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
            // save the last pass offsets
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
              pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  Socket=%u Controller=%u Channel=%u Lane=%u ShmooDir=%u Offset=%u\n",
              Socket, Controller, Channel, Lane, ShmooDir,
              pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif
          } // end for each shmoo direction
        } // end for each lane
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportLaneMarginResults

/**
  This function is used to report rank margin results.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         RMT result element type.
  @param[in]       ShmooDirCount      Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs         Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportRankMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType,
  IN UINT8 ShmooDirCount,
  IN CONST SHMOO_DIRECTION *pShmooDirs)
{
  UINT8 Socket, Controller, Channel, Dimm, Rank, Lane;
  UINT8 ShmooDirIdx;
  SHMOO_DIRECTION ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  UINT8 MinLaneLastPassLaneOffset;
  BOOLEAN IsDdrT;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportRankMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because 
        // we test DDR and DDRT together. 
        // We need to base on the socket, control, dimm to determine the IsDdrT field. 
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }
        if (GetResultElement(SsaServicesHandle, pCoreTestData, ResultType,
          pCoreTestData->CurrentIoLevel, IsDdrT, Socket,
          Controller, Channel, Dimm, Rank, 0, 0, 0, 0, &pElement)) {
          return 1;
        }

        // FOR each shmoo direction:
        for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
          ShmooDir = pShmooDirs[ShmooDirIdx];

          // preset the minimum lane last pass offset to the largest value
          MinLaneLastPassLaneOffset = 0xFF;

          // FOR each lane:
          for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
            // IF we found a last pass offset for this lane
            if ((pCoreTestData->LastPassFoundMasks[ShmooDir][Socket][Controller][Channel][Lane / 8] &
              (1 << (Lane % 8)))!= 0) {
                // IF this lane's last pass offset is less than the current minimum
                if (MinLaneLastPassLaneOffset >
                  pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane]) {
                    // this lane's last pass offset is the new minimum
                    MinLaneLastPassLaneOffset = \
                      pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];
                }
            }
            // ELSE we didn't find a last pass offset for this lane
            else {
              // the overall last pass offset is the minimum value
              MinLaneLastPassLaneOffset = 0;

              // exit the for lane loop now
              break;
            }
          } // end for each lane

          pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
            MinLaneLastPassLaneOffset;

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  Socket=%u Controller=%u Channel=%u ShmooDir=%u Offset=%u\n",
            Socket, Controller, Channel, ShmooDir, MinLaneLastPassLaneOffset);
#endif
        } // end for each shmoo direction
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportRankMarginResults

#if SUPPORT_FOR_TURNAROUNDS
/**
  The function is used to report rank-to-rank turnaround margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportTurnaroundMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Lane, DimmA, RankA, DimmB, RankB, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  UINT8 MinLaneLastPassLaneOffset;
  BOOLEAN IsDdrT;
#if MULTIPLE_R2R_TRAFFIC_MODES
  UINT8 DefaultMarginValue = 0xFF;
#else
  UINT8 DefaultMarginValue = 0;
#endif

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportTurnaroundMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not configured for rank-to-rank turnarounds THEN skip it
#if SUPPORT_FOR_EXTENDED_RANGE
        if (pCoreTestData->CurrentMemPointTestCfg.RankTestModes[Socket]\
          [Controller][Channel] != Turnarounds) {
          continue;
        }
#else
        if (pCoreTestData->SelectMemPointTestCfg.RankTestModes[Socket]\
          [Controller][Channel] != Turnarounds) {
          continue;
        }
#endif // !SUPPORT_FOR_EXTENDED_RANGE

        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        DimmA = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        RankA = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;
        DimmB = pCoreTestData->DimmRankBs[Socket][Controller][Channel].Dimm;
        RankB = pCoreTestData->DimmRankBs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because 
        // we test DDR and DDRT together. 
        // We need to base on the socket, control, dimm to determine the IsDdrT field. 
        // Also because DDRT dimm can only pair with DDRT dimm in turnaround test, we can safely
        // determine the dimm type by looking only at DimmA.
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }

        if (GetResultElement(SsaServicesHandle, pCoreTestData,
          TurnaroundRmtResultType, pCoreTestData->CurrentIoLevel,
          IsDdrT, Socket, Controller, Channel, DimmA,
          RankA, DimmB, RankB, 0, DefaultMarginValue, &pElement)) {
          return 1;
        }

        // FOR each shmoo direction:
        for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
          // preset the minimum lane last pass offset to the largest value
          MinLaneLastPassLaneOffset = 0xFF;

          // FOR each lane:
          for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
            // IF we found a last pass offset for this lane
            if ((pCoreTestData->LastPassFoundMasks[ShmooDir][Socket]\
              [Controller][Channel][Lane / 8] & (1 << (Lane % 8)))!= 0) {
                // IF this lane's last pass offset is less than the current
                // minimum
                if (MinLaneLastPassLaneOffset >
                  pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket]\
                  [Controller][Channel][Lane]) {
                    // this lane's last pass offset is the new minimum
                    MinLaneLastPassLaneOffset = \
                      pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket]\
                      [Controller][Channel][Lane];
                }
            }
            // ELSE we didn't find a last pass offset for this lane
            else {
              // the overall last pass offset is the minimum value
              MinLaneLastPassLaneOffset = 0;

              // exit the for lane loop now
              break;
            }
          } // end for each lane

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  Socket=%u Controller=%u Channel=%u ShmooDir=%u Offset=%u\n",
            Socket, Controller, Channel, ShmooDir, MinLaneLastPassLaneOffset);
#endif
#if MULTIPLE_R2R_TRAFFIC_MODES
          // IF the minimum last pass value is less than the current value THEN
          if (MinLaneLastPassLaneOffset < pElement->Margin\
            [pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]) {
#else
          {
#endif
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex]\
              [ShmooDir] = MinLaneLastPassLaneOffset;
          }
        } // end for each shmoo direction
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportTurnaroundMarginResults
#endif // SUPPORT_FOR_TURNAROUNDS

#if SUPPORT_FOR_LRDIMM
/**
  This function is used to copy the CmdAll margin results from rank 0 to the
  result structure for the current rank.  This is used for LPDDR devices for
  whom the CmdAll margin parameter is shared with all device ranks.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[out]      pAllRanksNonZero   Pointer to flag indicating whether ranks for all DIMMs were non-zero

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 CopyCmdAllResultsFromRank0(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  OUT BOOLEAN *pAllRanksNonZero)
{
  UINT8 Socket, Controller, Channel, Lane;
  BOOLEAN IsDdrT;
  RMT_RESULT_COLUMNS *pElement;
  UINT8 PairCount;
  DIMM_RANK_PAIR DimmRankPair;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.CopyCmdAllResultsFromRank0()\n");
#endif

  *pAllRanksNonZero = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
          Socket, Controller, Channel)) {
          continue;
        }

        PairCount = 1;
        if (pCoreTestData->GetPointTestDimmRanks(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->pCpgcPointTestData, Socket, Controller, Channel,
          &PairCount, &DimmRankPair, pCoreTestData->pTestStat)) {
          return 1;
        }

        // IF the rank is non-zero
        if ((PairCount != 0) && (DimmRankPair.Rank != 0)) {
          *pAllRanksNonZero = TRUE;

          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel]\
            [DimmRankPair.Dimm] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          // get the result element for this DIMM's rank 0
          pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
            Rank1RmtResultType, DdrLevel, IsDdrT, Socket, Controller, Channel,
            DimmRankPair.Dimm, 0, 0, 0, 0);

          if (pElement != NULL) {
            // FOR each lane:
            for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
              // use the rank 0 results for the current rank
              pCoreTestData->LastPassLaneOffsets[LoDirection][Socket][Controller][Channel][Lane] = \
                pElement->Margin[0][LoDirection];
              pCoreTestData->LastPassLaneOffsets[HiDirection][Socket][Controller][Channel][Lane] = \
                pElement->Margin[0][HiDirection];
            } // end for each lane
          } // end if the result element was found
        } // end if the rank is non-zero
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function CopyCmdAllResultsFromRank0
#endif // SUPPORT_FOR_LRDIMM

/**
  This function is used to initialize the common elements in the given results
  metadata structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.
  @param[in]       ResultEleCnt       Number of result elements.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitCommonMetadata(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN BOOLEAN HasDdrtDevices,
  IN UINT16 ResultEleCnt)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  RMT_RESULT_METADATA *pMetadata = pCoreTestData->pMetadata;
  GSM_LT IoLevel;
  BOOLEAN IsDdrT;
  UINT8 Socket = 0, Controller = 0, Channel = 0, Dimm = 0;
  UINT8 DdrSocket = 0, DdrController = 0, DdrChannel = 0, DdrDimm = 0;
  BOOLEAN DdrFound = FALSE;
#if SUPPORT_FOR_DDRT
  UINT8 DdrtSocket = 0, DdrtController = 0, DdrtChannel = 0, DdrtDimm = 0;
  BOOLEAN DdrtFound = FALSE;
#endif // SUPPORT_FOR_DDRT
  UINT8 Rank = 0;
  UINT8 LaneMasks[MAX_BUS_WIDTH / 8];
  INT16 MinOffset, MaxOffset;
  UINT16 Delay, StepUnit;
  SSA_STATUS RetStat;
  UINT16 Bitmask;

  pMetadata->EnableCtlAllMargin = pTestCfg->EnableCtlAllMargin;
  pMetadata->SinglesBurstLength = pTestCfg->SinglesBurstLength;
  pMetadata->SinglesLoopCount = pTestCfg->SinglesLoopCount;
  pMetadata->TurnaroundsBurstLength = pTestCfg->TurnaroundsBurstLength;
  pMetadata->TurnaroundsLoopCount = pTestCfg->TurnaroundsLoopCount;
  pMetadata->ScramblerOverrideMode = pTestCfg->ScramblerOverrideMode;

#if SUPPORT_FOR_EXTENDED_RANGE
  pCoreTestData->pMetadata->EnableExtendedRange = \
    pCoreTestData->pTestCfg->EnableExtendedRange;
#endif // SUPPORT_FOR_EXTENDED_RANGE

  bssa_memset(LaneMasks, 0xFF, sizeof(LaneMasks));

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // find the first available DDR DIMM
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // FOR each socket:
  for (DdrSocket = 0; DdrSocket < MAX_SOCKET_CNT; DdrSocket++) {
    if ((pCoreTestData->SystemInfo.SocketBitMask & (1 << DdrSocket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (DdrController = 0; DdrController < MAX_CONTROLLER_CNT; DdrController++) {
      if ((pCoreTestData->MemCfg.ControllerBitmasks[DdrSocket] &
        (1 << DdrController)) == 0) {
        continue;
      }

      // FOR each channel (while we haven't found a DDR device):
      for (DdrChannel = 0; DdrChannel < MAX_CHANNEL_CNT; DdrChannel++) {
        if ((pCoreTestData->MemCfg.ChannelBitmasks[DdrSocket][DdrController] &
          (1 << DdrChannel)) == 0) {
          continue;
        }

        // FOR each DIMM:
        for (DdrDimm = 0; DdrDimm < MAX_DIMM_CNT; DdrDimm++) {
          if ((pCoreTestData->MemCfg.DimmBitmasks[DdrSocket][DdrController][DdrChannel] &
            (1 << DdrDimm)) == 0) {
            continue;
          }

          // IF the device is not a DDR-T
          if (pCoreTestData->MemCfg.MemoryTech[DdrSocket][DdrController][DdrChannel][DdrDimm] !=
            SsaMemoryDdrT) {
            Bitmask = 1 << ((Controller * MAX_CHANNEL_CNT * MAX_DIMM_CNT) +
              (Channel * MAX_DIMM_CNT) + Dimm);

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
            // IF the system has no devices that support backside command
            // margining or this device supports backside command margining
            // (i.e., if the system has devices support backside command
            // margining then chose a device that support backside command
            // margining so that we can get the information for the
            // step unit info for backside CmdVref)
            if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) ||
              (pCoreTestData->BacksideCmdBitmasks[Socket] & Bitmask)) {
              DdrFound = TRUE;
              break;
            }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
          } // end if the device is not a DDR-T
        } // end for each DIMM

        if (DdrFound) {
          break;
        }
      } // end for each controller

      if (DdrFound) {
        break;
      }
    } // end for each controller

    if (DdrFound) {
      break;
    }
  } // end for each socket

#if SUPPORT_FOR_DDRT
  // IF the system has DDR-T devices
  if (HasDdrtDevices) {
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // find the first available DDR-T device
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // FOR each socket:
    for (DdrtSocket = 0; DdrtSocket < MAX_SOCKET_CNT; DdrtSocket++) {
      if ((pCoreTestData->SystemInfo.SocketBitMask & (1 << DdrtSocket)) == 0) {
        continue;
      }

      // FOR each controller:
      for (DdrtController = 0; DdrtController < MAX_CONTROLLER_CNT; DdrtController++) {
        if ((pCoreTestData->MemCfg.ControllerBitmasks[DdrtSocket] &
          (1 << DdrtController)) == 0) {
          continue;
        }

        // FOR each channel (while we haven't found a DDR device):
        for (DdrtChannel = 0; DdrtChannel < MAX_CHANNEL_CNT; DdrtChannel++) {
          if ((pCoreTestData->MemCfg.ChannelBitmasks[DdrtSocket][DdrtController] &
            (1 << DdrtChannel)) == 0) {
            continue;
          }

          // FOR each DIMM:
          for (DdrtDimm = 0; DdrtDimm < MAX_DIMM_CNT; DdrtDimm++) {
            if ((pCoreTestData->MemCfg.DimmBitmasks[DdrtSocket][DdrtController][DdrtChannel] &
              (1 << DdrtDimm)) == 0) {
              continue;
            }

            if (pCoreTestData->MemCfg.MemoryTech[DdrtSocket][DdrtController][DdrtChannel][DdrtDimm] == 
              SsaMemoryDdrT) {
              DdrtFound = TRUE;
              break;
            }
          } // end for each DIMM

          if (DdrtFound) {
            break;
          }
        } // end for each controller

        if (DdrtFound) {
          break;
        }
      } // end for each controller

      if (DdrtFound) {
        break;
      }
    } // end for each socket
  } // end if the system has DDR-T devices
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  assert(DdrLevel == 0);
  assert(LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (IoLevel = DdrLevel; IoLevel <= LrbufLevel; IoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask & (1 << IoLevel)) == 0) {
      continue;
    }
#else
  {
    IoLevel = DdrLevel;
#endif
#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices:
    for (IsDdrT = 0; IsDdrT <= 1; IsDdrT++) {
      // IF this is for DDR-T devices and the system has no DDR-T devices THEN skip it
      if (IsDdrT && !HasDdrtDevices) {
        continue;
      }
#else
    {
      IsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // backside THEN skip it
      if ((IoLevel == LrbufLevel) &&
        (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
        !pCoreTestData->MemCfg.IsLrDimms && !IsDdrT)) {
          continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

      // IF this is plain DDR
      if (IsDdrT == 0) {
#if SUPPORT_FOR_DDRT
        if (!DdrFound) {
          continue;
        }
#endif // SUPPORT_FOR_DDRT

        Socket = DdrSocket;
        Controller = DdrController;
        Channel = DdrChannel;
        Dimm = DdrDimm;
      }
#if SUPPORT_FOR_DDRT
      // ELSE this is DDR-T
      else {
        if (!DdrtFound) {
          continue;
        }

        Socket = DdrtSocket;
        Controller = DdrtController;
        Channel = DdrtChannel;
        Dimm = DdrtDimm;
      }
#endif // SUPPORT_FOR_DDRT

      // IF this is plain DDR
      if (IsDdrT == 0) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, RxDqsDelay);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, RxDqsDelay, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->PiStepUnit[IoLevel] = (UINT8) StepUnit;
        }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, RxVref);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, RxVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->RxVrefStepUnit[IoLevel] = StepUnit;
        }
      } // end if this is plain DDR

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
        "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
        Socket, Controller, Channel, Dimm, Rank, IoLevel, TxVref);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
        SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
        IoLevel, TxVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
      if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "    StepUnit=%d\n", StepUnit);
#endif
        pMetadata->TxVrefStepUnit[IsDdrT][IoLevel] = StepUnit;
      }

      // IF rank margining is enabled and either the I/O level is the frontside
      // or the system has devices that support backside command margining
      if (pTestCfg->EnableRankMargin
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        &&
        ((IoLevel == DdrLevel) ||
        IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        ) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, CmdVref);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, CmdVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->CmdVrefStepUnit[IsDdrT][IoLevel] = StepUnit;
        }
      } // end if rank margining is enabled
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

  pMetadata->BusWidth = pCoreTestData->SystemInfo.BusWidth;
  pMetadata->BusFreq = pCoreTestData->SystemInfo.BusFreq;

  SsaServicesHandle->SsaMemoryConfig->GetMemVoltage(SsaServicesHandle,
    &pMetadata->MemVoltage);

  pMetadata->ResultEleCount = ResultEleCnt;

  return 0;
} // end function InitCommonMetadata

/**
  This function is used to set up the results.  It creates the results buffer
  and gets a pointer to the metadata structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultEleCnt       Number of RMT result elements required.
  @param[out]      ppMetadata         Pointer to pointer to results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 SetupResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT32 ResultEleCnt,
  OUT RMT_RESULT_METADATA **ppMetadata)
{
  SSA_STATUS RetStat;
  SSA_STATUS RequestedResultEleCntRetStat;
  UINT32 MetadataSize      = sizeof(RMT_RESULT_METADATA);
  UINT32 ResultElementSize = sizeof(RMT_RESULT_COLUMNS);
  EFI_GUID MetadataGuid = RMT_RESULT_METADATA_GUID;
  EFI_GUID ColumnsGuid = RMT_RESULT_COLUMNS_GUID;
  RMT_RESULT_METADATA *pMetadata;
  TEST_STATUS *pTestStat;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "SetupResults(ResultEleCnt=%u)\n", ResultEleCnt);
#endif

  // --------------------------------------------------------------------------
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CreateResultBuffer(MetadataSize=%u ResultElementSize=%u ResultEleCnt=%u)\n",
    MetadataSize, ResultElementSize, ResultEleCnt);
#endif
  RequestedResultEleCntRetStat = SsaServicesHandle->SsaResultsConfig->CreateResultBuffer(
    SsaServicesHandle, MetadataSize, ResultElementSize, ResultEleCnt);

  // IF we couldn't create the result buffer with the requested number of result elements
  if (RequestedResultEleCntRetStat != Success) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: Unable to create result buffer with requested number of elements (%u).\n",
      ResultEleCnt);

    // IF both frontside and backside margining are enabled OR both per-rank and
    // per-lane results are enabled
    if (((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << DdrLevel)) &&
      (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) ||
      ((pCoreTestData->pTestCfg->EnableRankMargin) &&
      (pCoreTestData->pTestCfg->EnableLaneMargin))) {
      // just return the error - the calling function will disable backside
      // margining and/or per-lane results and try again
      return 1;
    }

    // try again with a single result element so that we can report the error
    ResultEleCnt = 1;
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  CreateResultBuffer(MetadataSize=%u ResultElementSize=%u ResultsCapacity=%u\n",
      MetadataSize, ResultElementSize, ResultEleCnt);
#endif
    RetStat = SsaServicesHandle->SsaResultsConfig->CreateResultBuffer(
      SsaServicesHandle, MetadataSize, ResultElementSize, ResultEleCnt);
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, NULL)) {
      return 1;
    }
  } // end if we couldn't create the result buffer ...

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  GetMetadata()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->GetMetadata(
    SsaServicesHandle, ppMetadata);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, NULL)) {
    return 1;
  }

  pMetadata = *ppMetadata;

  // zero the metadata
  bssa_memset(pMetadata, 0, sizeof(*pMetadata));

  // set the version information
  pMetadata->MajorVer = BSSA_TC_MAJOR_VER;
  pMetadata->MinorVer = BSSA_TC_MINOR_VER;
  pMetadata->RevVer = BSSA_TC_REV_VER;
  pMetadata->BuildVer = BSSA_TC_BUILD_VER;

  pTestStat = (TEST_STATUS*) &pMetadata->StatusCode;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SetMetadataType()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->SetMetadataType(
    SsaServicesHandle, &MetadataGuid);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
    return 1;
  }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SetResultElementType()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->SetResultElementType(
    SsaServicesHandle, &ColumnsGuid);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
    return 1;
  }

  // IF we couldn't create the result buffer with the requested number of result elements
  if (RequestedResultEleCntRetStat != Success) {
    RMT_RESULT_COLUMNS *pElement;

    // we need to process the one element so that the columnar GUID shows up in the result
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  GetNextResultElement()\n");
#endif
    RetStat = SsaServicesHandle->SsaResultsConfig->GetNextResultElement(
      SsaServicesHandle, &pElement);
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
      return 1;
    }

    // just set the element values to all 0's
    bssa_memset(pElement, 0, sizeof(*pElement));
  }

  // complete processing of the return status from the call to
  // CreateResultBuffer with the requested number of result elements
  if (ChkRetStat(SsaServicesHandle, RequestedResultEleCntRetStat, __FILE__,
    __LINE__, pTestStat)) {
    return 1;
  }

  return 0;
} // end function SetupResults

/**
  This function is used to log the RMT test configuration.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in]       pRmtTestCfg        Pointer to RMT test configuration structure.
**/
VOID LogRmtTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST RMT_CONFIG *pRmtTestCfg)
{
#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "LogRmtTestCfg()\n");
#endif

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "\n"
    "RMT Configuration:\n");
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SocketBitmask=0x%X\n", pRmtTestCfg->SocketBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ControllerBitmask=0x%X\n", pRmtTestCfg->ControllerBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  IoLevelBitmask=0x%X\n", pRmtTestCfg->IoLevelBitmask);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableRankMargin=%u\n", pRmtTestCfg->EnableRankMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableCtlAllMargin=%u\n", pRmtTestCfg->EnableCtlAllMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableLaneMargin=%u\n", pRmtTestCfg->EnableLaneMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableTurnaroundMargin=%u\n", pRmtTestCfg->EnableTurnaroundMargin);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  RxDqsStepSize=%u\n", pRmtTestCfg->RxDqsStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TxDqStepSize=%u\n", pRmtTestCfg->TxDqStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  RxVrefStepSize=%u\n", pRmtTestCfg->RxVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TxVrefStepSize=%u\n", pRmtTestCfg->TxVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CmdAllStepSize=%u\n", pRmtTestCfg->CmdAllStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CmdVrefStepSize=%u\n", pRmtTestCfg->CmdVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CtlAllStepSize=%u\n", pRmtTestCfg->CtlAllStepSize);
#if SUPPORT_FOR_DDRT
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EridDelayStepSize=%u\n", pRmtTestCfg->EridDelayStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EridVrefStepSize=%u\n", pRmtTestCfg->EridVrefStepSize);
#endif

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesBurstLength=%u\n", pRmtTestCfg->SinglesBurstLength);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesLoopCount=%u\n", pRmtTestCfg->SinglesLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesBinarySearchLoopCount=%u\n", pRmtTestCfg->SinglesBinarySearchLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsBurstLength=%u\n", pRmtTestCfg->TurnaroundsBurstLength);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsLoopCount=%u\n", pRmtTestCfg->TurnaroundsLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsBinarySearchLoopCount=%u\n", pRmtTestCfg->TurnaroundsBinarySearchLoopCount);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  OptimizedShmooBitmask=0x%08X\n", pRmtTestCfg->OptimizedShmooBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ScramblerOverrideMode=%u\n", pRmtTestCfg->ScramblerOverrideMode);
#if SUPPORT_FOR_EXTENDED_RANGE
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableExtendedRange=%u\n", pRmtTestCfg->EnableExtendedRange);
#endif // SUPPORT_FOR_EXTENDED_RANGE
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableTestResultLogging=%u\n", pRmtTestCfg->EnableTestResultLogging);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableLaneMarginPlot=%u\n", pRmtTestCfg->EnableLaneMarginPlot);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TestStatusLogLevel=%u\n", pRmtTestCfg->TestStatusLogLevel);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "\n");
} // end function LogRmtTestCfg

/**
  This function is used to check the RMT test configuration for correctness.
  Some test configuration values may be updated based on their value and the
  given memory configuration.

  @param[in, out]  SsaServicesHandle          Pointer to SSA services.
  @param[in, out]  pCoreTestData              Pointer to RMT core test data.
  @param[in]       MaxIoLevelBitMask          Maximum I/O level bitmask value.
  @param[in]       IsLoopCountExponential     Boolean value indicating whether or not loop count value is exponential.
  @param[in]       MaxLoopCountVal            The maximum loop count value.  If IsLoopCountExponential is TRUE then the MaxLoopCountVal value is the maximum exponent value.
  @param[in]       MaxBurstLengthExponentVal  The maximum burst length exponent value.  For a CPGC engine that doesnt support exponential burst length values, this value should be 0.
  @param[in]       MaxBurstLengthLinearVal    The maximum burst length linear value.  Some CPGC engines use linear for smaller values and exponential (2^n) for larger values.  For a CPGC engine that doesnt support linear burst length values, this value should be 0.
  @param[out]      pTestStat                  Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
SSA_STATUS ChkRmtTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT8 MaxIoLevelBitMask,
  IN BOOLEAN IsLoopCountExponential,
  IN UINT32 MaxLoopCountVal,
  IN UINT8 MaxBurstLengthExponentVal,
  IN UINT32 MaxBurstLengthLinearVal)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  TEST_STATUS *pTestStat = pCoreTestData->pTestStat;
  UINT8 BurstLengthExponent;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "ChkRmtTestCfg()\n");
#endif

  if ((pTestCfg->IoLevelBitmask == 0) ||
    (pTestCfg->IoLevelBitmask > MaxIoLevelBitMask)) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: IoLevelBitmask value (0x%X) is out of range (0 < val <= 0x%X).\n",
      pTestCfg->IoLevelBitmask, MaxIoLevelBitMask);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->RxDqsStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: RxDqsStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->RxDqsStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->TxDqStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: TxDqStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->TxDqStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->RxVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: RxVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->RxVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->TxVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: TxVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->TxVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CmdAllStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CmdAllStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CmdAllStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CmdVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CmdVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CmdVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CtlAllStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CtlAllStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CtlAllStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  BurstLengthExponent = GetHighestBitSetInMask(pTestCfg->SinglesBurstLength, 32);

  if (!((pTestCfg->SinglesBurstLength != 0) &&
        (((pTestCfg->SinglesBurstLength == (1 << BurstLengthExponent)) &&
          ((UINT32) pTestCfg->SinglesBurstLength <= ((UINT32) 1 << MaxBurstLengthExponentVal))) ||
         (((UINT32) pTestCfg->SinglesBurstLength <= MaxBurstLengthLinearVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
     "ERROR: SinglesBurstLength value (%u) is out of range.\n",
     pTestCfg->SinglesBurstLength);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (!((pTestCfg->SinglesLoopCount != 0) &&
        ((IsLoopCountExponential &&
         (pTestCfg->SinglesLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
        (!IsLoopCountExponential &&
         (pTestCfg->SinglesLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
     "ERROR: SinglesLoopCount value (%u) is out of range.\n",
     pTestCfg->SinglesLoopCount);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (!((pTestCfg->SinglesBinarySearchLoopCount != 0) &&
    ((IsLoopCountExponential &&
    (pTestCfg->SinglesBinarySearchLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
    (!IsLoopCountExponential &&
    (pTestCfg->SinglesBinarySearchLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: SinglesBinarySearchLoopCount value (%u) is out of range.\n",
      pTestCfg->SinglesBinarySearchLoopCount);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

#if SUPPORT_FOR_TURNAROUNDS
  // IF rank-to-rank turnaround testing is enabled
  if (pTestCfg->EnableTurnaroundMargin) {
    BurstLengthExponent = GetHighestBitSetInMask(pTestCfg->TurnaroundsBurstLength, 32);

    if (!((pTestCfg->TurnaroundsBurstLength != 0) &&
      (((pTestCfg->TurnaroundsBurstLength == (1 << BurstLengthExponent)) &&
      ((UINT32) pTestCfg->TurnaroundsBurstLength <= ((UINT32) 1 << MaxBurstLengthExponentVal))) ||
      (((UINT32) pTestCfg->TurnaroundsBurstLength <= MaxBurstLengthLinearVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsBurstLength value (%u) is out of range.\n",
        pTestCfg->TurnaroundsBurstLength);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }

    // IF the rank-to-rank turnarounds uses the three special traffic types
    if (pCoreTestData->TurnaroundsPairMode == OrderIndependent) {
      if ((pTestCfg->TurnaroundsBurstLength < 8) || (pTestCfg->TurnaroundsBurstLength > 512)) {
#if ENBL_VERBOSE_ERROR_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ERROR: TurnaroundsBurstLength value (%u) is out of range.\n",
          pTestCfg->TurnaroundsBurstLength);
#endif
        ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
        return 1;
      }
    } // end if the rank-to-rank turnarounds uses the three special traffic types

    if (!((pTestCfg->TurnaroundsLoopCount != 0) &&
      ((IsLoopCountExponential &&
      (pTestCfg->TurnaroundsLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
      (!IsLoopCountExponential &&
      (pTestCfg->TurnaroundsLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsLoopCount value (%u) is out of range.\n",
        pTestCfg->TurnaroundsLoopCount);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }

    if (!((pTestCfg->TurnaroundsBinarySearchLoopCount != 0) &&
      ((IsLoopCountExponential &&
      (pTestCfg->TurnaroundsBinarySearchLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
      (!IsLoopCountExponential &&
      (pTestCfg->TurnaroundsBinarySearchLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsBinarySearchLoopCount value (%u) is out of range.\n",
        pTestCfg->TurnaroundsBinarySearchLoopCount);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }
  } // end if rank-to-rank turnaround testing is enabled
#endif // SUPPORT_FOR_TURNAROUNDS

  return 0;
} // end function ChkRmtTestCfg

/**
  This function is the memory point test result handler function.

  This function conforms to the MEM_POINT_TEST_RESULT_HANDLER typedef in MemPointTest.h.

  @param[in, out]  SsaServicesHandle     Pointer to SSA services.
  @param[in]       pSystemInfo           Pointer to system information structure.
  @param[in, out]  pVoidTestData         Pointer to client test data.
  @param[in]       Socket                Socket tested.
  @param[in]       Controller            Controller tested.
  @param[in]       Channel               Channel tested.
  @param[in]       DimmRankA             First DIMM+Rank tested.
  @param[in]       DimmRankB             Second DIMM+Rank tested.
  @param[in]       RankCombinationIndex  Rank combination index tested.
  @param[in]       pLaneErrorStatus      Pointer to array of lane error status masks.  Number of array elements is SystemInfo.BusWidth/8
  @param[in]       ErrorCount            Channel error count.
  @param[out]      pTestStat             Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 RmtPointTestResultHandler(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST MRC_SYSTEM_INFO *pSystemInfo,
  IN OUT VOID *pVoidTestData,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN DIMM_RANK_PAIR DimmRankA,
  IN DIMM_RANK_PAIR DimmRankB,
  IN UINT8 RankCombinationIndex,
  IN CONST UINT8 *pLaneErrorStatus,
  IN ERROR_COUNT_32BITS ErrorCount,
  OUT TEST_STATUS *pTestStat)
{
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pVoidTestData;
  UINT8 Lane;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtPointTestResultHandler(Socket=%u Controller=%u Channel=%u\n",
    Socket, Controller, Channel);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  DimmA=%u RankA=%u DimmB=%u RankB=%u RankCombinationIndex=%u)\n",
    DimmRankA.Dimm, DimmRankA.Rank, DimmRankB.Dimm, DimmRankB.Rank, RankCombinationIndex);
#endif
  // IF this channel isn't actually enabled for validation (can occur if this
  // channel has less than the maximum number of rank combinations and the
  // ExtendedRange feature is enabled )THEN skip it
  if (!IsChannelValEnabled(SsaServicesHandle, pSystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif
    Socket, Controller, Channel)) {
    return 0;
  }

  // save the current rank values (for result reporting)
  pCoreTestData->DimmRankAs[Socket][Controller][Channel] = DimmRankA;
  pCoreTestData->DimmRankBs[Socket][Controller][Channel] = DimmRankB;

  // FOR each lane:
  for (Lane = 0; Lane < pSystemInfo->BusWidth; Lane++) {
    // IF this lane didn't detect errors
    if ((pLaneErrorStatus[Lane / 8] & (1 << (Lane % 8))) == 0) {
      // set the lane's last-pass-found status
      pCoreTestData->LastPassFoundMasks[pCoreTestData->CurrentShmooDirection] \
        [Socket][Controller][Channel][Lane / 8] |= 1 << (Lane % 8);

      // IF the offset we're testing at is greater than the current last pass
      // offset THEN it's the new last pass offset
      if (ABS(pCoreTestData->TestingOffset) >
        pCoreTestData->LastPassLaneOffsets[pCoreTestData->CurrentShmooDirection] \
        [Socket][Controller][Channel][Lane]) {
        pCoreTestData->LastPassLaneOffsets[pCoreTestData->CurrentShmooDirection] \
          [Socket][Controller][Channel][Lane] = \
          (UINT8) ABS(pCoreTestData->TestingOffset);
      }
    } // end else this lane didn't detect errors
  } // end for each lane

  return 0;
} // end function RmtPointTestResultHandler

/**
  The function is used to get the number of RMT columnar result elements
  required.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.
  @param[out]      pResultEleCnt      Pointer to where result element count will be placed.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 GetResultEleCnt(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN BOOLEAN HasDdrtDevices,
  OUT UINT16 *pResultEleCnt)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  UINT8 Socket, Controller, Channel;
  RANK_COMBINATION_CNTS RankCombinationsCnts;
  BOOLEAN InitAsAll;
#if SUPPORT_FOR_TURNAROUNDS
  BOOLEAN CanDoTurnarounds;
#endif // SUPPORT_FOR_TURNAROUNDS

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.GetResultEleCnt(HasDdrtDevices=%u)\n", HasDdrtDevices);
#endif

  *pResultEleCnt = 0;

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  assert(DdrLevel == 0);
  assert(LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (pCoreTestData->CurrentIoLevel = DdrLevel;
    pCoreTestData->CurrentIoLevel <= LrbufLevel; pCoreTestData->CurrentIoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask & (1 << pCoreTestData->CurrentIoLevel)) == 0) {
      continue;
    }
#else
  {
    pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

// PT can be optimized to remove the #if SUPPORT_FOR_DDRT
#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0; pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF rank margining is enabled and the I/O level is the backside
      if ((pTestCfg->EnableRankMargin) &&
        (pCoreTestData->CurrentIoLevel == LrbufLevel)) {
        // initialize the bitmask of DIMMs that support backside command
        // margining
        // only use the first two entries if CtlAll margining is not enabled
        UINT8 CmdMarginGroupCount = \
          (pCoreTestData->pTestCfg->EnableCtlAllMargin) ? 3 : 2;

        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, CmdVref, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
          MarginGroups[1], CmdMarginGroupCount,
          pCoreTestData->BacksideCmdBitmasks);
      } // end if rank margining is enabled and the I/O level is the backside
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // backside THEN skip it
      if ((pCoreTestData->CurrentIoLevel == LrbufLevel) &&
        !IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
        !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices) {
        continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
      //- - - - - - - - -- - - - - - - - - - - - -- - - - - - - - - - - - -- -
      // determine whether at least one channel can do turnarounds
      //- - - - - - - - -- - - - - - - - - - - - -- - - - - - - - - - - - -- -
      InitAsAll = FALSE;
      if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
        pCoreTestData->CurrentIoLevel, GsmGtMax, Turnarounds,
        pCoreTestData->CurrentIsDdrT, InitAsAll)) {
        return 1;
      }

      if (GetRankCombinationsCnts(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
        &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
        pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
        pCoreTestData->pTestStat)) {
        return 1;
      }

      CanDoTurnarounds = FALSE;
      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            // IF this channel is not enabled for validation THEN skip it
            if (!IsChannelValEnabled(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg, Socket, Controller, Channel)) {
              continue;
            }

            if (CanChannelDoTurnarounds(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg,
              pCoreTestData->CurrentIoLevel, Socket, Controller, Channel,
              pCoreTestData->CurrentIsDdrT)) {
              CanDoTurnarounds = TRUE;
              break;
            }
          } // end for each channel

          if (CanDoTurnarounds) {
            break;
          }
        } // end for each controller

        if (CanDoTurnarounds) {
          break;
        }
      } // end for each socket
#endif // SUPPORT_FOR_TURNAROUNDS

#if SUPPORT_FOR_TURNAROUNDS
      // IF rank or lane margining is enabled or turnaround margining is
      // enabled and at least one channel can do turnarounds
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin ||
        (pTestCfg->EnableTurnaroundMargin && CanDoTurnarounds)) {
#else
      // IF rank or lane margining is enabled
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) {
#endif // !SUPPORT_FOR_TURNAROUNDS
        // one element for all ranks for the Tx/Rx margin parameter limits
        // one for DDR and one for DDRT
        *pResultEleCnt += 1; 
#if SUPPORT_FOR_DDRT
        *pResultEleCnt += 1; 
#endif // SUPPORT_FOR_DDRT
#if ENBL_RESULTS_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
          *pResultEleCnt, ParamLimits0ResultType, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT);
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          " Qty=%u\n", 1);
#endif
      } // end if rank or lane margining is enabled ...

#if SUPPORT_FOR_DDRT
      // IF Early Read ID margining is enabled AND there is DDR-T device
      // AND this is for the frontside
      if ((pCoreTestData->pTestCfg->EnableEridMargin) &&
        HasDdrtDevices &&
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {
        // one element for the Early Read ID margin limits
        *pResultEleCnt += 1;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
          *pResultEleCnt, ParamLimits2ResultType, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT);
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          " Qty=%u\n", 1);
#endif
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, GsmGtMax, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              // one element for each rank combination for the Early Read
              // ID margin data
              *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel];

#if ENBL_RESULTS_DEBUG_LOG_MSGS
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                *pResultEleCnt, Rank2RmtResultType,
                pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                Socket, Controller, Channel,
                RankCombinationsCnts[Socket][Controller][Channel]);
#endif
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if Early Read ID margining is enabled AND ...
#endif // SUPPORT_FOR_DDRT

      // IF rank or lane margining is enabled and this is the frontside or
      // there are devices with a backside of Rx/Tx timing and voltage
      if ((pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) &&
        ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
        pCoreTestData->MemCfg.IsLrDimms || HasDdrtDevices)) {
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, GsmGtMax, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              // IF rank margining is enabled
              if (pTestCfg->EnableRankMargin) {
                // one element for each rank combination for the Tx/Rx margin data
                *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel];

#if ENBL_RESULTS_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, Rank0RmtResultType, pCoreTestData->CurrentIoLevel,
                  pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  RankCombinationsCnts[Socket][Controller][Channel]);
#endif
              } // end if rank margining is enabled

              // IF lane margining is enabled
              if (pTestCfg->EnableLaneMargin) {
                // one element for each rank combination and each lane
                *pResultEleCnt += \
                  RankCombinationsCnts[Socket][Controller][Channel] * \
                  pCoreTestData->SystemInfo.BusWidth;

#if ENBL_RESULTS_DEBUG_LOG_MSGS >= 1
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, LaneRmtResultType, pCoreTestData->CurrentIoLevel,
                  pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  (RankCombinationsCnts[Socket][Controller][Channel] * \
                  pCoreTestData->SystemInfo.BusWidth));
#endif
              } // end if lane margining is enabled
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank or lane margining is enabled and ...

      // IF rank margining is enabled
      if (pTestCfg->EnableRankMargin) {
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        // IF we're margining the frontside or the system contains devices
        // that support backside command margining
        if ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
          IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        {
          // one element for all ranks for the Cmd/Ctl margin parameter limits
          *pResultEleCnt += 1;
#if SUPPORT_FOR_DDRT
          *pResultEleCnt += 1; 
#endif // SUPPORT_FOR_DDRT

#if ENBL_RESULTS_DEBUG_LOG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
            *pResultEleCnt, ParamLimits1ResultType, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentIsDdrT);
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Qty=%u\n", 1);
#endif
        } // end if we're margining the frontside or ...

        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, CmdVref, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        // IF this is the backside:
        if (pCoreTestData->CurrentIoLevel == LrbufLevel) {
          // remove DIMMs that don't support backside command margining
          RemoveNonBacksideCmdDimms(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            pCoreTestData->BacksideCmdBitmasks,
            &pCoreTestData->SelectMemPointTestCfg);
        } // end if this is not the frontside
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              // IF we're margining the frontside or the system contains
              // devices that support backside command margining
              if ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
                IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              {
                // one element for each rank combination for the Cmd/Ctl margin data
                *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel];

#if ENBL_RESULTS_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, Rank1RmtResultType,
                  pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  RankCombinationsCnts[Socket][Controller][Channel]);
#endif
              } // end if this is for the frontside or ...
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank margining is enabled

#if SUPPORT_FOR_TURNAROUNDS
      // IF rank-to-rank turnaround margining is enabled
      if (pTestCfg->EnableTurnaroundMargin) {
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, GsmGtMax, Turnarounds,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for testing THEN skip it
              if (!IsChannelTestingEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              //// IF this channel can't do turnarounds THEN skip it
              //if (!CanChannelDoTurnarounds(&pCoreTestData->SystemInfo,
              //  &pCoreTestData->MemCfg, &pCoreTestData->MemPointTestCfg,
              //  IoLevel, Socket, Controller, Channel)) continue;

              // one element for each rank combination
              *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel];

#if ENBL_RESULTS_DEBUG_LOG_MSGS
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                *pResultEleCnt, TurnaroundRmtResultType,
                pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                Socket, Controller, Channel,
                RankCombinationsCnts[Socket][Controller][Channel]);
#endif
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank-to-rank turnaround margining is enabled
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

#if ENBL_RESULTS_DEBUG_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ResultEleCnt=%u\n", *pResultEleCnt);
#endif

  return 0;
} // end function GetResultEleCnt

/**
  This function is used to run the RMT test.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       SetupSameRankForDataMargin  Pointer to function to setup point test for same rank traffic for data signal margining.
  @param[in]       SetupSameRankForCmdMargin  Pointer to function to setup point test for same rank traffic for command/address/control signal margining.
  @param[in]       SetupTurnaroundForDataMargin  Pointer to function to setup point test for rank-to-rank turnaround traffic for data signal margining.
  @param[in]       SetupSameRankForEridMargin  Pointer to function to setup point test for same rank traffic for DDR-T Early Read ID signal margining.
  @param[in]       InitSpecificMetadata  Pointer to function to initialize product specific metadata.  A NULL value is acceptable.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 RunRmt(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SETUP_RMT_SAME_RANK_FOR_DATA_MARGIN SetupSameRankForDataMargin,
  IN SETUP_RMT_SAME_RANK_FOR_CMD_MARGIN SetupSameRankForCmdMargin,
#if SUPPORT_FOR_TURNAROUNDS
  IN SETUP_RMT_TURNAROUND_FOR_DATA_MARGIN SetupTurnaroundForDataMargin,
#endif
#if SUPPORT_FOR_DDRT
  IN SETUP_RMT_SAME_RANK_FOR_ERID_MARGIN SetupSameRankForEridMargin,
#endif // SUPPORT_FOR_DDRT
  IN INIT_SPECIFIC_METADATA InitSpecificMetadata)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  UINT16 ResultEleCnt = 0;
  SHMOO_STOP_MODE LaneShmooStopMode;
  BOOLEAN HasDdrtDevices = FALSE;
  UINT8 Socket;
  SSA_STATUS RetStat;
  SHMOO_DIRECTION ShmooDirs[] = { LoDirection, HiDirection };
  UINT8 ShmooDirCount = sizeof(ShmooDirs) / sizeof(ShmooDirs[0]);
  BOOLEAN InitDqdbContent;
  BOOLEAN InitAsAll;
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  SETUP_CLEANUP SetupCleanup;
  // only use the first two entries if CtlAll margining is not enabled
  UINT8 CmdMarginGroupCount = (pCoreTestData->pTestCfg->EnableCtlAllMargin) ? 3 : 2;
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RunRmt()\n");
#endif

#ifdef __STUB__
  // check design assumptions about the uniformity of margin parameter grouping by type
  {
    UINT8 SubIndex;
    GSM_GT MarginGroup;

    // FOR each margin parameter group in the first array:
    for (SubIndex = 0; SubIndex < MARGIN_GROUP_ARRAY_ELE_CNT; SubIndex++) {
      MarginGroup = MarginGroups[0][SubIndex];
      assert((MarginGroup == GsmGtMax) || !IsCmdSignalMarginGroup(MarginGroup));
      MarginGroup = MarginGroups[1][SubIndex];
      assert((MarginGroup == GsmGtMax) || IsCmdSignalMarginGroup(MarginGroup));
#if SUPPORT_FOR_DDRT
      MarginGroup = MarginGroups[2][SubIndex];
      assert((MarginGroup == GsmGtMax) || !IsCmdSignalMarginGroup(MarginGroup));
#endif // SUPPORT_FOR_DDRT
    }
  }
#endif // __STUB__

#if SUPPORT_FOR_DDRT
  HasDdrtDevices = GetHasDdrtDevices(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg);
#endif // SUPPORT_FOR_DDRT

  // get the required number of columnar result elements
  if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
    &ResultEleCnt)) {
    return 1;
  }

  // setup the results
  if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
    &pCoreTestData->pMetadata)) {
    // IF both frontside and backside margining are enabled OR per-lane results
    // are enabled
    if (((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << DdrLevel)) &&
      (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) ||
      (pCoreTestData->pTestCfg->EnableLaneMargin)) {
      // IF backside margining is enabled
      if (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel)) {
        // try again with the backside margining disabled
        pCoreTestData->pTestCfg->IoLevelBitmask &= ~(1 << LrbufLevel);

        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "NOTE: Backside margin testing overridden to disabled due to insufficient memory available for results.\n");
      }

      if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
        &ResultEleCnt)) {
          return 1;
      }
      if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
        &pCoreTestData->pMetadata)) {
        // IF both per-rank and per-lane results are enabled
        if ((pCoreTestData->pTestCfg->EnableRankMargin) &&
          (pCoreTestData->pTestCfg->EnableLaneMargin)) {
          // try again with per-lane results disabled
          pCoreTestData->pTestCfg->EnableLaneMargin = FALSE;

          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "NOTE: Per-lane margin testing overridden to disabled due to insufficient memory available for results.\n");

          if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
            &ResultEleCnt)) {
              return 1;
          }
          if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
            &pCoreTestData->pMetadata)) {
              return 1;
          }
        } // end if per-lane results are enabled
      } // end if SetupResults failed
    } // end if both frontside and backside margining are enabled OR ...
  } // end if SetupResults failed

  pCoreTestData->pTestStat = (TEST_STATUS*) &pCoreTestData->pMetadata->StatusCode;

  // initialize the metadata
  if (InitCommonMetadata(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
    ResultEleCnt)) {
    return 1;
  }

  if (InitSpecificMetadata != NULL) {
    InitSpecificMetadata(SsaServicesHandle, pCoreTestData);
  }

  // initialize the CPGC test configuration to default values
  SetCpgcPointTestCfgDefaults(&pCoreTestData->CpgcPointTestCfg);

  // initialize the DQDB content for all devices that will be participating
  // (SelectMemPointTestCfg is currently configured for all devices - both DDR
  // and DDR-T)
  InitDqdbContent = TRUE;
  if (InitDqdb(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pCoreTestData->pCpgcInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    InitDqdbContent, pCoreTestData->pTestStat)) {
    return 1;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // non command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  // FOR each I/O level:
#ifdef __STUB__
  // confirm design assumption
  assert(DdrLevel == 0);
  assert(LrbufLevel == 1);
#endif // __STUB__
  for (pCoreTestData->CurrentIoLevel = DdrLevel;
    pCoreTestData->CurrentIoLevel <= LrbufLevel;
    pCoreTestData->CurrentIoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask &
      (1 << pCoreTestData->CurrentIoLevel)) == 0) {
      continue;
    }
#else
  {
    pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // back side THEN skip it
      if ((pCoreTestData->CurrentIoLevel == LrbufLevel) && \
        !pCoreTestData->MemCfg.IsLrDimms &&
        !HasDdrtDevices) {
        continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // same rank margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF rank or lane margining is enabled:
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) {
        LaneShmooStopMode = (pTestCfg->EnableLaneMargin) ? AllShmooStopMode : AnyShmooStopMode;

        // pre-setup for the first margin parameter (so we can get the maximum
        // number of rank combinations)
        if (SetupSameRankForDataMargin(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
          pTestCfg->EnableLaneMargin)) {
          return 1;
        }

        // get the rank combination counts
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // IF there are rank combinations to test
        if (pCoreTestData->MaxRankCombinationCnt) {
          // FOR each margin parameter group in the first array:
          for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
            pCoreTestData->CurrentMarginGroupSubIndex < \
            (sizeof(MarginGroups[0]) / sizeof(MarginGroups[0][0]));
            pCoreTestData->CurrentMarginGroupSubIndex++) {
            pCoreTestData->CurrentMarginGroup = \
              MarginGroups[0][pCoreTestData->CurrentMarginGroupSubIndex];

            // IF the margin group is not valid THEN skip it
            if (pCoreTestData->CurrentMarginGroup == GsmGtMax) {
              continue;
            }

            if (pTestCfg->TestStatusLogLevel >= 1) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing IoLevel=%s MarginGroup=%s\n",
                GetIoLevelStr(pCoreTestData->CurrentIoLevel),
                GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
            }

            // FOR each rank combination:
            for (pCoreTestData->CurrentRankCombinationIndex = 0;
              pCoreTestData->CurrentRankCombinationIndex <
              pCoreTestData->MaxRankCombinationCnt;
              pCoreTestData->CurrentRankCombinationIndex++) {

              if (pTestCfg->TestStatusLogLevel >= 2) {
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing same rank traffic for rank combination %u of %u.\n",
                  (pCoreTestData->CurrentRankCombinationIndex + 1),
                  pCoreTestData->MaxRankCombinationCnt);
              }

              // The "UpdateHwSetting=FALSE", only set up the dimm/rank in the channel test data structure,
              // it need a following call with "UpdateHwSetting=TRUE" to apply to HW.
              // PT should change the API to use an enum: update_local_data_structure, update_hw, both
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                FALSE,
                pCoreTestData->pTestStat)) {
                return 1;
              }
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                TRUE,
                pCoreTestData->pTestStat)) {
                  return 1;
              }

              // initialize the last pass margin status
              InitMarginStatus(pCoreTestData);

              // run the series of Margin1D tests
              if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                return 1;
              }

              // report the margin parameter limits in the test results, update the 
              // limit per each rank iteration. 
              if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                ParamLimits0ResultType)) {
                return 1;
              }

              // IF rank margining is enabled
              if (pTestCfg->EnableRankMargin) {
                if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
                  Rank0RmtResultType, ShmooDirCount, &ShmooDirs[0])) {
                  return 1;
                }
              }

              // IF lane margining is enabled:
              if (pTestCfg->EnableLaneMargin) {
                if (ReportLaneMarginResults(SsaServicesHandle, pCoreTestData)) {
                  return 1;
                }
              }
            } // end for each each rank combination

#if SUPPORT_FOR_EXTENDED_RANGE
            // IF extended range and rank margining are enabled
            if (pCoreTestData->pTestCfg->EnableExtendedRange &&
              pCoreTestData->pTestCfg->EnableRankMargin) {
              // fixup the rank margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, Rank0RmtResultType)) {
                return 1;
              }
            }

            // IF extended range and lane margining are enabled
            if (pCoreTestData->pTestCfg->EnableExtendedRange &&
              pCoreTestData->pTestCfg->EnableLaneMargin) {
              // fixup the lane margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, LaneRmtResultType)) {
                return 1;
              }
            }
#endif // SUPPORT_FOR_EXTENDED_RANGE
          } // end for each margin parameter group in the first array
        } // end if there are rank combinations to test
      } // end if rank or lane margining is enabled

#if SUPPORT_FOR_DDRT
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // Early Read ID margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF Early Read ID margining is enabled AND this is for DDR-T devices
      // AND this is for the frontside
      if (pCoreTestData->pTestCfg->EnableEridMargin &&
        HasDdrtDevices && 
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {
        MARGIN_PARAM_SPECIFICITY Specificity;

        LaneShmooStopMode = AllShmooStopMode;

        // setup for Early Read ID testing
        if (SetupSameRankForEridMargin(SsaServicesHandle, pCoreTestData)) {
          return 1;
        }

        // get the rank combination counts with the new MemPointTestCfg
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
          &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each margin parameter group in the third array:
        for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
          pCoreTestData->CurrentMarginGroupSubIndex <
          (sizeof(MarginGroups[2]) / sizeof(MarginGroups[2][0]));
        pCoreTestData->CurrentMarginGroupSubIndex++) {
          pCoreTestData->CurrentMarginGroup = \
            MarginGroups[2][pCoreTestData->CurrentMarginGroupSubIndex];

          // IF the margin group is not valid THEN skip it
          if (pCoreTestData->CurrentMarginGroup == GsmGtMax) {
            continue;
          }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  GetMarginParamSpecificity(IoLevel=%u MarginGroup=%u)\n",
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamSpecificity(
            SsaServicesHandle, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentMarginGroup, &Specificity);

          // IF this margin parameter isn't supported THEN skip it
          if (RetStat == UnsupportedValue) {
            continue;
          }

          if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          if (pTestCfg->TestStatusLogLevel >= 1) {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "\n"
              "Testing IoLevel=%s MarginGroup=%s\n",
              GetIoLevelStr(pCoreTestData->CurrentIoLevel),
              GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
          }

          // FOR each rank combination:
          for (pCoreTestData->CurrentRankCombinationIndex = 0;
            pCoreTestData->CurrentRankCombinationIndex <
            pCoreTestData->MaxRankCombinationCnt;
            pCoreTestData->CurrentRankCombinationIndex++) {
            if (pTestCfg->TestStatusLogLevel >= 2) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing same rank traffic for rank combination %u of %u.\n",
                (pCoreTestData->CurrentRankCombinationIndex + 1),
                pCoreTestData->MaxRankCombinationCnt);
            }

            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              FALSE,
              pCoreTestData->pTestStat)) {
              return 1;
            }
            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              TRUE,
              pCoreTestData->pTestStat)) {
                return 1;
            }

            // initialize the last pass margin status
            InitMarginStatus(pCoreTestData);

            // run the series of Margin1D tests
            if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
              LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
              return 1;
            }

            // report the margin parameter limits in the test results, update the 
            // limit per each rank iteration. 
            if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
              ParamLimits2ResultType)) {
              return 1;
            }

            if (ReportEridMarginResults(SsaServicesHandle, pCoreTestData)) {
              return 1;
            }
          } // end for each rank combination
        } // end for each margin parameter group in the third array
      } // end if Early Read ID margining is enabled and ...
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // rank-to-rank turnaround margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF rank-to-rank turnaround margining is enabled
      if (pTestCfg->EnableTurnaroundMargin) {
        TRAFFIC_MODE TrafficMode = LoopbackTrafficMode;
#if MULTIPLE_R2R_TRAFFIC_MODES
        TRAFFIC_MODE TrafficModes[] = {
          Wr2WrAndRd2RdTrafficMode,
          Rd2WrTrafficMode,
          Wr2RdTrafficMode
        };
        UINT8 TrafficModeIdx;
#endif // MULTIPLE_R2R_TRAFFIC_MODES
        LaneShmooStopMode = AnyShmooStopMode;

#if MULTIPLE_R2R_TRAFFIC_MODES
        // FOR each rank-to-rank traffic mode:
        for (TrafficModeIdx = 0;
          TrafficModeIdx < (sizeof(TrafficModes) / sizeof(TrafficModes[0]));
          TrafficModeIdx++) {
          TrafficMode = TrafficModes[TrafficModeIdx];
#else
        {
          TrafficMode = LoopbackTrafficMode;
#endif // !MULTIPLE_R2R_TRAFFIC_MODES
          // pre-setup for the first margin parameter (so we can get the maximum
          // number of rank combinations)
          if (SetupTurnaroundForDataMargin(SsaServicesHandle, pCoreTestData,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            TrafficMode)) {
            return 1;
          }

          // get the rank combination counts
          if (GetRankCombinationsCnts(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            &pCoreTestData->SelectMemPointTestCfg,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            &pCoreTestData->RankCombinationCnts,
            &pCoreTestData->MaxRankCombinationCnt,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          // IF there are rank combinations to test
          if (pCoreTestData->MaxRankCombinationCnt) {
            // FOR each margin parameter group in the first array:
            for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
              pCoreTestData->CurrentMarginGroupSubIndex < \
              (sizeof(MarginGroups[0]) / sizeof(MarginGroups[0][0]));
              pCoreTestData->CurrentMarginGroupSubIndex++) {
              pCoreTestData->CurrentMarginGroup = \
                MarginGroups[0][pCoreTestData->CurrentMarginGroupSubIndex];

              // IF the margin parameter group is not valid THEN skip it
              if (pCoreTestData->CurrentMarginGroup == GsmGtMax) {
                continue;
              }

              if (pTestCfg->TestStatusLogLevel >= 1) {
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing IoLevel=%s MarginGroup=%s\n",
                  GetIoLevelStr(pCoreTestData->CurrentIoLevel),
                  GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
              }

              // FOR each rank combination:
              for (pCoreTestData->CurrentRankCombinationIndex = 0;
                pCoreTestData->CurrentRankCombinationIndex <
                pCoreTestData->MaxRankCombinationCnt;
                pCoreTestData->CurrentRankCombinationIndex++) {
                if (pTestCfg->TestStatusLogLevel >= 2) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "\n"
                    "Testing rank-to-rank turnaround traffic for rank combination %u of %u.\n",
                    (pCoreTestData->CurrentRankCombinationIndex + 1),
                    pCoreTestData->MaxRankCombinationCnt);
                }

                if (pCoreTestData->SetPointTestRankCombinationIndex(
                  SsaServicesHandle, &pCoreTestData->SystemInfo,
                  &pCoreTestData->MemCfg,
                  &pCoreTestData->SelectMemPointTestCfg,
                  &pCoreTestData->CpgcPointTestCfg,
                  pCoreTestData->pCpgcPointTestData,
                  pCoreTestData->CurrentRankCombinationIndex,
                  FALSE,
                  pCoreTestData->pTestStat)) {
                  return 1;
                }
                if (pCoreTestData->SetPointTestRankCombinationIndex(
                  SsaServicesHandle, &pCoreTestData->SystemInfo,
                  &pCoreTestData->MemCfg,
                  &pCoreTestData->SelectMemPointTestCfg,
                  &pCoreTestData->CpgcPointTestCfg,
                  pCoreTestData->pCpgcPointTestData,
                  pCoreTestData->CurrentRankCombinationIndex,
                  TRUE,
                  pCoreTestData->pTestStat)) {
                    return 1;
                }

                // initialize the last pass margin status
                InitMarginStatus(pCoreTestData);

                // run the series of Margin1D tests
                if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
                  LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                  return 1;
                }

                // IF rank and lane margining are not enabled
                // report the margin parameter limits in the test results, update the 
                // limit per each rank iteration. 
                if ((!pTestCfg->EnableRankMargin && !pTestCfg->EnableLaneMargin)) {
                  // report the margin parameter limits in the test results
                  if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                    ParamLimits0ResultType)) {
                    return 1;
                  }
                }

                if (ReportTurnaroundMarginResults(SsaServicesHandle,
                  pCoreTestData)) {
                  return 1;
                }
              } // end for each rank combination

#if SUPPORT_FOR_EXTENDED_RANGE
              // fixup the rank-to-rank turnaround margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, TurnaroundRmtResultType)) {
                return 1;
              }
#endif // SUPPORT_FOR_EXTENDED_RANGE
            } // end for each margin parameter group in the first array
          } // end if there are rank combinations to test
        } // end for each rank-to-rank traffic mode
      } // end if rank-to-rank turnaround margining is enabled
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // frontside command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // IF rank margining and frontside testing are enabled
  if ((pTestCfg->EnableRankMargin) && (pTestCfg->IoLevelBitmask & (1 << DdrLevel))) {
    pCoreTestData->CurrentIoLevel = DdrLevel;

    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF this socket is not enabled for testing THEN skip it
      if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
        ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
        continue;
      }

      // all command/control margin parameters share a common initialization
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=Setup)\n",
        Socket, pCoreTestData->CurrentIoLevel, CmdAll);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
        SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll, Setup);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  RetStat=%u\n", RetStat);
#endif
        return 1;
      }
    } // end for each socket

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
      {
        pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

        LaneShmooStopMode = AnyShmooStopMode;

        if (SetupSameRankForCmdMargin(SsaServicesHandle,
          pCoreTestData, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT)) {
          return 1;
        }

        // get the rank combination counts with the new MemPointTestCfg
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt, pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each margin parameter group in the second array:
        for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
          pCoreTestData->CurrentMarginGroupSubIndex < \
          (sizeof(MarginGroups[1]) / sizeof(MarginGroups[1][0]));
          pCoreTestData->CurrentMarginGroupSubIndex++) {
          pCoreTestData->CurrentMarginGroup = \
            MarginGroups[1][pCoreTestData->CurrentMarginGroupSubIndex];

          // IF the margin parameter group is not valid THEN skip it
          if (pCoreTestData->CurrentMarginGroup == GsmGtMax) {
            continue;
          }

          // IF the margin parameter group is CtlAll and CtlAll is not enabled THEN skip it
          if ((pCoreTestData->CurrentMarginGroup == CtlAll) &&
            !pTestCfg->EnableCtlAllMargin) {
            continue;
          }

          if (pTestCfg->TestStatusLogLevel >= 1) {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "\n"
              "Testing IoLevel=%s MarginGroup=%s\n",
              GetIoLevelStr(pCoreTestData->CurrentIoLevel),
              GetMarginGroupStr(pCoreTestData->CurrentMarginGroup));
          }

          // FOR each rank combination:
          for (pCoreTestData->CurrentRankCombinationIndex = 0;
            pCoreTestData->CurrentRankCombinationIndex < \
            pCoreTestData->MaxRankCombinationCnt;
            pCoreTestData->CurrentRankCombinationIndex++) {
            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              FALSE,
              pCoreTestData->pTestStat)) {
              return 1;
            }
            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              TRUE,
              pCoreTestData->pTestStat)) {
                return 1;
            }

#if SUPPORT_FOR_LRDIMM
            // IF the margin parameter is CmdAll and the system has LRDIMMs
            if ((pCoreTestData->CurrentMarginGroup == CmdAll) &&
              pCoreTestData->MemCfg.IsLrDimms) {
              BOOLEAN AllRanksNonZero;

              // copy the results from the rank=0 test case for non-zero ranks
              if (CopyCmdAllResultsFromRank0(SsaServicesHandle, pCoreTestData,
                &AllRanksNonZero)) {
                return 1;
              }

              // IF the ranks for all DIMMs were non-zero
              if (AllRanksNonZero) {
                if (pTestCfg->TestStatusLogLevel >= 2) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "Skipping same rank traffic for rank combination %u of %u\n",
                    (pCoreTestData->CurrentRankCombinationIndex + 1),
                    pCoreTestData->MaxRankCombinationCnt);
                }

                // skip the actual testing
                continue;
              }
            } // end if the margin parameter is CmdAll and the system has LRDIMMs
#endif // SUPPORT_FOR_LRDIMM

            if (pTestCfg->TestStatusLogLevel >= 2) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing same rank traffic for rank combination %u of %u.\n",
                (pCoreTestData->CurrentRankCombinationIndex + 1),
                pCoreTestData->MaxRankCombinationCnt);
          }

          // initialize the last pass margin status
          InitMarginStatus(pCoreTestData);

          // run the series of Margin1D tests
          if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
            LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
            return 1;
          }

          // report the margin parameter limits in the test results, update the 
          // limit per each rank iteration. 
          if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
            ParamLimits1ResultType)) {
            return 1;
          }

          if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
            Rank1RmtResultType, ShmooDirCount, &ShmooDirs[0])) {
            return 1;
          }
        } // end for each rank combination

#if SUPPORT_FOR_EXTENDED_RANGE
        // fixup the command margin results
        if (FixupResults(SsaServicesHandle, pCoreTestData,
          LoThenHiDirection, Rank1RmtResultType)) {
          return 1;
        }
#endif // SUPPORT_FOR_EXTENDED_RANGE
      } // end for each margin parameter group in the second array
    } // end for non-DDR-T and DDR-T devices 

    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF this socket is not enabled for testing THEN skip it
      if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
        ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
        continue;
      }

      // all command/control margin parameters share a common initialization
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=Cleanup)\n",
        Socket, pCoreTestData->CurrentIoLevel, CmdAll);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
        SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll, Cleanup);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
        return 1;
      }
    } // end for each socket
  } // end if rank margining and frontside testing are enabled

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // backside command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // IF rank margining and backside testing are enabled
  if ((pTestCfg->EnableRankMargin) && (pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) {
    BOOLEAN BacksideCmdDevicesExist = FALSE;

    pCoreTestData->CurrentIoLevel = LrbufLevel;

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 1;
      pCoreTestData->CurrentIsDdrT++) {
        // IF this is for DDR-T devices and the system has no DDR-T devices THEN skip it
        if (pCoreTestData->CurrentIsDdrT && !HasDdrtDevices) {
          continue;
        }
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

      // initialize the bitmask of DIMMs that support backside command
      // margining
      InitAsAll =FALSE;
      if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
        pCoreTestData->CurrentIoLevel, CmdVref, Singles,
        pCoreTestData->CurrentIsDdrT, InitAsAll)) {
        return 1;
      }

      InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
        MarginGroups[1], CmdMarginGroupCount,
        pCoreTestData->BacksideCmdBitmasks);

      // IF there are devices with a command back side
      if (IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks)) {
        BacksideCmdDevicesExist = TRUE;
#if SUPPORT_FOR_DDRT
        break;
#endif // !SUPPORT_FOR_DDRT
      }
    } // end for non-DDR-T and DDR-T devices

    // IF there are devices that support backside command margining
    if (BacksideCmdDevicesExist) {
      UINT8 ShmooDirIdx;

      // FOR each shmoo direction (backside command margin parameters must have
      // the calls to InitMarginParam performed in a per shmoo direction basis):
      for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // IF this socket is not enabled for testing THEN skip it
          if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
            ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
            continue;
          }

          // NOTE: Backside command margining setup/cleanup is different for
          // high and low sides so we're piggybacking the shmoo direction in
          // the Setup/Cleanup parameter.
          SetupCleanup = Setup;
          SetupCleanup |= ShmooDirs[ShmooDirIdx] << 1;
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=%u)\n",
            Socket, pCoreTestData->CurrentIoLevel, CmdAll, SetupCleanup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
            SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll,
            SetupCleanup);
          if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat)) {
            return 1;
          }
        } // end for each socket

#if SUPPORT_FOR_DDRT
        // FOR non-DDR-T and DDR-T devices (they're tested separately because their
        // margin parameters are different and therefore may have different ranges):
        for (pCoreTestData->CurrentIsDdrT = 0;
          pCoreTestData->CurrentIsDdrT <= 0;
          pCoreTestData->CurrentIsDdrT++) {
#else
        {
          pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

          // initialize the bitmask of DIMMs that support backside command
          // margining
          InitAsAll = FALSE;
          if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
            pCoreTestData->CurrentIoLevel, CmdVref, Singles,
            pCoreTestData->CurrentIsDdrT, InitAsAll)) {
            return 1;
          }

          InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
            &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
            MarginGroups[1], CmdMarginGroupCount,
            pCoreTestData->BacksideCmdBitmasks);

          // IF there are no devices with a command back side THEn skip it
          if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks)) {
            continue;
          }

          LaneShmooStopMode = AnyShmooStopMode;

          if (SetupSameRankForCmdMargin(SsaServicesHandle,
            pCoreTestData, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentIsDdrT)) {
            return 1;
          }

          // get the rank combination counts with the new MemPointTestCfg
          if (GetRankCombinationsCnts(SsaServicesHandle,\
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            &pCoreTestData->SelectMemPointTestCfg,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            &pCoreTestData->RankCombinationCnts,
            &pCoreTestData->MaxRankCombinationCnt,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          // IF there are no rank combinations for this CurrentIsDdrT setting THEN skip it
          if (pCoreTestData->MaxRankCombinationCnt == 0) {
            continue;
          }

          // FOR each margin parameter group in the second array:
          for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
            pCoreTestData->CurrentMarginGroupSubIndex < \
            (sizeof(MarginGroups[1]) / sizeof(MarginGroups[1][0]));
            pCoreTestData->CurrentMarginGroupSubIndex++) {
            pCoreTestData->CurrentMarginGroup = \
              MarginGroups[1][pCoreTestData->CurrentMarginGroupSubIndex];

            // IF the margin parameter group is not valid THEN skip it
            if (pCoreTestData->CurrentMarginGroup == GsmGtMax) {
              continue;
            }

            // IF the margin parameter group is CtlAll and CtlAll is not enabled THEN skip it
            if ((pCoreTestData->CurrentMarginGroup == CtlAll) &&
              !pTestCfg->EnableCtlAllMargin) {
              continue;
            }

            if (pTestCfg->TestStatusLogLevel >= 1) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing IoLevel=%s MarginGroup=%s ShmooDirection=%s\n",
                GetIoLevelStr(pCoreTestData->CurrentIoLevel),
                GetMarginGroupStr(pCoreTestData->CurrentMarginGroup),
                ((ShmooDirs[ShmooDirIdx] == LoDirection) ? "low":"high"));
            }

            // FOR each rank combination:
            for (pCoreTestData->CurrentRankCombinationIndex = 0;
              pCoreTestData->CurrentRankCombinationIndex < \
              pCoreTestData->MaxRankCombinationCnt;
              pCoreTestData->CurrentRankCombinationIndex++) {
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                FALSE,
                pCoreTestData->pTestStat)) {
                return 1;
              }
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                TRUE,
                pCoreTestData->pTestStat)) {
                  return 1;
              }
              if (pTestCfg->TestStatusLogLevel >= 2) {
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing same rank traffic for rank combination %u of %u\n",
                  (pCoreTestData->CurrentRankCombinationIndex + 1),
                  pCoreTestData->MaxRankCombinationCnt);
              }

              // initialize the last pass margin status
              InitMarginStatus(pCoreTestData);

              // run the series of Margin1D tests
              if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {
                return 1;
              }

              // report the margin parameter limits in the test results, update the 
              // limit per each rank iteration. 
              if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                ParamLimits1ResultType)) {
                return 1;
              }

              if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
                Rank1RmtResultType, 1, &ShmooDirs[ShmooDirIdx])) {
                return 1;
              }
            } // end for each rank combination

#if SUPPORT_FOR_EXTENDED_RANGE
            // fixup the command margin results
            if (FixupResults(SsaServicesHandle, pCoreTestData,
              ShmooDirs[ShmooDirIdx], Rank1RmtResultType)) {
              return 1;
            }
#endif // SUPPORT_FOR_EXTENDED_RANGE
          } // end for each margin parameter group in the second array
        } // end non-DDR-T and DDR-T devices

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // IF this socket is not enabled for testing THEN skip it
          if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
            ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
              continue;
          }

          // NOTE: Backside command margining setup/cleanup is different for
          // high and low sides so we're piggybacking the shmoo direction in
          // the Setup/Cleanup parameter.
          SetupCleanup = Cleanup;
          SetupCleanup |= ShmooDirs[ShmooDirIdx] << 1;
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=%u)\n",
            Socket, pCoreTestData->CurrentIoLevel, CmdAll, SetupCleanup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
            SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll,
            SetupCleanup);
          if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat)) {
            return 1;
          }
        } // end for each socket
      } // end for each shmoo direction
    } // end if there are devices that support backside command margining
  } // end if rank margining and backside testing are enabled
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // log results
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  if (pTestCfg->EnableTestResultLogging) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "\n"
      "* = not tested\n"
      "\n"
      "START_BSSA_RMT\n"
      "\n");

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
    // confirm design assumption
    assert(DdrLevel == 0);
    assert(LrbufLevel == 1);
#endif // __STUB__
    // FOR each I/O level:
    for (pCoreTestData->CurrentIoLevel = DdrLevel;
      pCoreTestData->CurrentIoLevel <= LrbufLevel;
      pCoreTestData->CurrentIoLevel++) {
      // IF this I/O level is not enabled for testing THEN skip it
      if ((pCoreTestData->pTestCfg->IoLevelBitmask &
        (1 << pCoreTestData->CurrentIoLevel)) == 0) {
          continue;
      }

      // IF the I/O level is the backside
      if (pCoreTestData->CurrentIoLevel == LrbufLevel) {
        // initialize the bitmask of DIMMs that support backside command
        // margining
        pCoreTestData->CurrentIsDdrT = FALSE;

        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, GsmGtMax, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
            return 1;
        }

        InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
          MarginGroups[1], CmdMarginGroupCount,
          pCoreTestData->BacksideCmdBitmasks);

        // IF there are no devices with a backside THEN skip it
        if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
          !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices) {
          continue;
        }
      } // end if the I/O level is not the frontside
#else
    {
      pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

      if (pTestCfg->EnableRankMargin) {
        LogRankMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      } // end if rank margining is enabled

#if SUPPORT_FOR_DDRT
      if (pCoreTestData->pTestCfg->EnableEridMargin && HasDdrtDevices &&
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {
          LogEridMarginResults(SsaServicesHandle, pCoreTestData);
      }
#endif
      if (pTestCfg->EnableLaneMargin) {
        LogLaneMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      }

#if SUPPORT_FOR_TURNAROUNDS
      if (pTestCfg->EnableTurnaroundMargin) {
        LogTurnaroundMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      }
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for each I/O level

    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "STOP_BSSA_RMT\n");

    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "MMA metadata: BusFreq=%u MHz\n", pCoreTestData->SystemInfo.BusFreq);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "MMA metadata: MemVoltage=%u mV\n", pCoreTestData->pMetadata->MemVoltage);

    {
      UINT8 Socket, Controller, Channel, Dimm;
      UINT8 MemoryTech;
      BOOLEAN Found = FALSE;

      // find the first DIMM
      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            if (!IsChannelTestingEnabled(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
              Channel)) {
              continue;
            }

            // FOR each DIMM:
            for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
              if ((pCoreTestData->SelectMemPointTestCfg.DimmABitmasks[Socket][Controller][Channel] &
                (1 << Dimm)) == 0) {
                continue;
              }

              MemoryTech = pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm];

#if SUPPORT_FOR_DDRT
              if (MemoryTech == SsaMemoryDdrT) {
                continue;
              }
#endif // SUPPORT_FOR_DDRT

              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "MMA metadata: MemoryTech=0x%X\n", MemoryTech);

              Found = TRUE;
              break;
            } // end for each DIMM

            if (Found) {
              break;
            }
          } // end for each channel

          if (Found) {
            break;
          }
        } // end for each controller

        if (Found) {
          break;
        }
      } // end for each socket
    }
  } // end if test result logging is enabled

  if (pTestCfg->EnableLaneMarginPlot) {
    if (pTestCfg->EnableLaneMargin) {
      if (PlotLaneMarginResults(SsaServicesHandle, pCoreTestData,
        HasDdrtDevices)) {
        return 1;
      }
    }
  } // end if lane margin plotting is enabled

  return 0;
} // end function RunRmt

#endif  // SSA_FLAG

// end file RmtCore.c
