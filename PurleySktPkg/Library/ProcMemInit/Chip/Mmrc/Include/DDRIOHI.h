/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    DDRIOHI.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in DDRIOHI.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _DDRIOHI_H_
#define _DDRIOHI_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_DDRIOHI_REG                                   0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DID_DDRIOHI_REG                                   0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2069
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_DDRIOHI_STRUCT;
#endif // ASM_INC

#define PCICMD_DDRIOHI_REG                                0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define PCISTS_DDRIOHI_REG                                0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RID_DDRIOHI_REG                                   0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_DDRIOHI_STRUCT;
#endif // ASM_INC

#define CCR_DDRIOHI_REG                                   0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_DDRIOHI_STRUCT;
#endif // ASM_INC

#define CLSR_DDRIOHI_REG                                  0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_DDRIOHI_STRUCT;
#endif // ASM_INC

#define PLAT_DDRIOHI_REG                                  0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_DDRIOHI_STRUCT;
#endif // ASM_INC

#define HDR_DDRIOHI_REG                                   0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_DDRIOHI_STRUCT;
#endif // ASM_INC

#define BIST_DDRIOHI_REG                                  0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_DDRIOHI_STRUCT;
#endif // ASM_INC

#define CAPPTR_DDRIOHI_REG                                0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_DDRIOHI_STRUCT;
#endif // ASM_INC

#define INTL_DDRIOHI_REG                                  0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define INTPIN_DDRIOHI_REG                                0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define MINGNT_DDRIOHI_REG                                0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_DDRIOHI_STRUCT;
#endif // ASM_INC

#define MAXLAT_DDRIOHI_REG                                0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CKE_DDRIOHI_REG                      0x00000800
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value, Normally updated by Comp FSM via CompBus. can be overriden via message
    // channel if periodical retrain is disabled. 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value, Normally updated by Comp FSM via CompBus. can be overriden via
    // message channel if periodical retrain is disabled. 
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // not used
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CKE_DDRIOHI_REG                0x00000804
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Enable DDRT Parity in CMDCTL
    // 
    // Bits[28:17], RW_L, default = 0x0
    //
    UINTX ddrcmdctlrx_en : 12;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING_CKE_DDRIOHI_REG                  0x00000808
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode0 : 6;
    //
    // Cmd Pi Logic Delay - add 1 qclk cycle delay.
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay0 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel0 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode1 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay1 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel1 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode2 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay2 : 2;
    //
    // not used
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel2 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CKE_DDRIOHI_REG                  0x0000080C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Phased based xtalk cancellation is enabled, set this to delay cmd to maintain
    // constant Tcwl. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX ddrphasextalkenableqnnnh : 1;
    //
    // Enable Visa debug bus LCB for CMD fub
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // enable PiRef clock divider in xover
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX pirefclkdivenable : 1;
    //
    // Xover Select between grid-PiRef and PiRef-PiN
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX xoveropmode : 1;
    //
    // On weak lock exit, controls how long the feedback to the phase detector is masked:
    // {0: 1 qclk (required for delayline latency), 1: 2 qclk, 2: 3 qclk, 3: 4 qclk}
    // 
    // Bits[5:4], RW_L, default = 0x0
    //
    UINTX dllmask : 2;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Forces the CMD transmitter on, overriding any power downs
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Forces on all PI enables and the LCB enables in the AFE fubs.  Does not force
    // on D0 PI enable or override weaklock mode. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX intclkon : 1;
    //
    // not used 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX repclkon : 1;
    //
    // Controls IO Loopback.  Ctl[1] enables IOLB mode and Ctl[0] controls if this is
    // a Setup(0) or Hold(1) test 
    // 
    // Bits[11:10], RW_L, default = 0x0
    //
    UINTX iolbctl : 2;
    //
    // Forces the driver in ODT mode, where both the pullup and pulldown are enabled.
    //  Used for Rstray testing 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // not used
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX cmdtxeq : 2;
    //
    // Controls the number of segments enabled during the early warning weak drive: {0:
    // All Enabled, 1: Enable Seg[4], 2: Enable Seg[4:3], 3: Enable Seg[4:2]} 
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX earlyweakdrive : 2;
    //
    // not used
    //         
    // 
    // Bits[18:17], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
    //
    // not used
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // IOLB Vref Control.  2s compliment encoding from 1/3 Vdd to 2/3 Vdd with step size
    // of Vdd/192 (7.8mV) 
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX rxvref : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX halflsbbit : 1;
    //
    //  Vref Disable
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vrefdisable : 1;
    //
    // Ddr4 Mode Enable, set to 1 in CMD2 (Func:5.Addr:C00 and Func:7.Addr:C00) fub to
    // bypass extra delay on parity bit 
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddr4modeenable : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS2_CKE_DDRIOHI_REG                 0x00000810
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdCtl RxVoSel or RxVocPassGateEn  for CmdCtl Receiver
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdrxvocpassgateen : 12;
    //
    // FNV Cmd Power Down
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX fnvcrcmdpowerdown : 1;
    //
    // FNV Cr Cmd Is CKE
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX fnvcrcmdiscke : 6;
    //
    // FNV Cmd Sample Enable
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX fnvcmdsampleen : 1;
    //
    // FNV DDR/PI Bypass Enable
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX fnvddrcrdllpibypassen : 1;
    //
    // Enable finer vref resolution in ddr4
    //         
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // BDX change : This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[22:22], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
    //
    // CmdRxBiasSel for Cmd Receiver
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX cmdrxbiassel : 1;
    //
    // ForceCmdBiason for Cmd Receiver
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX forcecmdbiason : 1;
    //
    // bypass ddrcmdctl xover for FNV
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX fnvcmdcrxoverbypassen : 1;
    //
    // CmdCtl Buffer CtleCapEn
    // 
    // Bits[27:26], RW_L, default = 0x0
    //
    UINTX cmdctlecapen : 2;
    //
    // CmdCtl Buffer CtleResEn
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX cmdctleresen : 2;
    //
    // RxOffsetCodeUngate or CmdRxOffsetCtlEnable for CmdCtl Rx buffer
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX rxoffsetcodeungate : 1;
    //
    // SaOffsetTrainTxOn or CmdSaOffsetTrain for Cmd buf
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS2_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMP_CKE_DDRIOHI_REG                      0x00000814
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // LevelShift Comp Value
    // 
    // Bits[27:25], RW_L, default = 0x0
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMP_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMPOFFSET_CKE_DDRIOHI_REG                0x00000818
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdctlbufsel : 6;
    //
    // Is the Direction (RX/TX Valid)
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX iodirectionvalid : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMPOFFSET_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CKE_DDRIOHI_REG                 0x0000081C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Drive strength enable for CmdBuf/CtlBuf.
    // 
    // Bits[4:0], RW_L, default = 0x1F
    //
    UINTX bufdrvsegen : 5;
    //
    // control the DdrVrefSelDQQnnnH pin on the ddrvrefint generator
    // 
    // Bits[5:5], RW_L, default = 0x1
    //
    UINTX cmdvrefpgen : 1;
    //
    // OdtStrength 
    // 
    // Bits[6:6], RW_L, default = 0x1
    //
    UINTX odtstrength : 1;
    //
    // spare1
    // 
    // Bits[8:7], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Invert DAlign 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX divby2alignctl : 1;
    //
    // select qclk for cmdxover instead of Dclk 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX divby2disable : 1;
    //
    // ODTDis for Cmd and Ctl buf
    // 
    // Bits[22:11], RW_L, default = 0x0
    //
    UINTX odten : 12;
    //
    // CmdRefClk
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX cmdrefpiclkdelay : 6;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLRANKSUSED_CKE_DDRIOHI_REG                 0x00000820
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables output buffers for ctlbufpair 0 to ctlbufpair6 , PI clocks and output
    // datapaths for this rank 
    // 
    // Bits[5:0], RW_L, default = 0x3F
    //
    UINTX ranken : 6;
    //
    // Spare
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX spare : 6;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // used to compensate the GCN skew. The GCN skew information should be
    //           extracted by reading and analyzing the final Rcomp code value. The target
    // spec 
    //           is to categorize the GCN skew in 3 process condition (mainly slow, fast,
    // typical). 
    //           (one example can be just reading the 2 MLS bit of Rcomp code and determine
    // if the 
    //           GCN is slow, fast or typical). The gcncomp is used for CTLE.
    //           11: gcn in slow corner
    //           10: gcn in typical corner
    //           01: gcn in fast corner
    //         
    // 
    // Bits[14:13], RW_L, default = 0x2
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Imode bias DFx leg control
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // Imode bias control
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX imodebiashighcm : 1;
    //
    // Rx bias Sel
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // CmdRxEqQnnnL for RX CmdCtl Buf 
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX cmdrxeqqnnnl : 3;
    //
    // spare
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // CmdRxBiasCtl for RX biasgen 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasctl : 3;
    //
    // CmdPcasBiasClosedLoopEnQnnnH for RX biasgen 
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX cmdpcasbiasclosedloopen : 1;
    //
    // DdrCmdRxBiasFoldedLegTrim for RX biasgen 
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasfoldedlegtrim : 2;
    //
    // spare1
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare2 : 2;
  } Bits;
  UINTX Data;
} DDRCRCTLRANKSUSED_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADC_CKE_DDRIOHI_REG                   0x00000824
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADC_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDACIOLB_CKE_DDRIOHI_REG                    0x00000828
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACIO Enable
    // The MISR Logic Enable control bit is a master switch that enables the clock to
    // all of the logic  
    // and circuits that are specific to the command/control ACIO loopback feature. The
    // MISR Logic Enable bit  
    // must be set to one whenever the loopback/MISR logic needs to be used. It should
    // be set to zero otherwise,  
    // so that clock power is not wasted.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX acioen : 1;
    //
    // ACIO MISR Clear
    // The MISR Clear control bit resets the entire shift register to all zero. 
    // The reset is triggered by the zero-to-one transition of the MISR Clear bit, 
    // and after the clear operation is done, the MISR Operation Done bit is set to one.
    //         
    // 
    // Bits[1:1], RW_V, default = 0x0
    //
    UINTX acioclear : 1;
    //
    // ACIO MISR Auto Start
    // The MISR Auto Start control bit arms the control logic to start signature accumulation
    // when it detects  
    // the first non-zero value on the trigger lane. Once the signature collection has
    // been started,  
    // the MISR Auto Start bit is automatically cleared, but the MISR Operation Done
    // bit is set. 
    //         
    // 
    // Bits[2:2], RW_V, default = 0x0
    //
    UINTX acioautostart : 1;
    //
    // ACIO MISR Manual Start
    // The MISR Manual Start bit is a control bit that starts signature collection immediately.
    //  
    // In this case, the control logic does not consider the state of the trigger lane.
    // Signature collection is triggered exclusively by the zero-to-one transition of
    // the MISR Manual Start bit.  
    // Once signature collection is started, the MISR Manual Start bit is automatically
    // cleared,  
    // but the MISR Operation Done bit is set.
    //         
    // 
    // Bits[3:3], RW_V, default = 0x0
    //
    UINTX aciomanustart : 1;
    //
    // ACIO MISR Busy indication
    // The MISR Busy bit indicates that signature collection is running. 
    // It is set when the signature collection timer starts and cleared when the timer
    // stops. 
    //         
    // 
    // Bits[4:4], RO_V, default = 0x0
    //
    UINTX aciomisrbusy : 1;
    //
    // ACIO MISR Operation Done indication
    // The MISR Operation Done bit is set to one whenever a clear, start or shift operation
    // has occurred.  
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[5:5], RW1C, default = 0x0
    //
    UINTX aciomisropdone : 1;
    //
    // ACIO MISR Collection Done indication
    // The MISR Collection Done bit is set to one whenever a signature collection 
    // phase finishes, that is when the signature collection timer stops. 
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[6:6], RW1C, default = 0x0
    //
    UINTX aciomisrcollectdone : 1;
    //
    // Spare0
    //         
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // ACIOData Parallel Out
    // The MISR Data Out bit is a read-only bit that's essentially one bit in the MISR's
    // shift  
    // (or rotate) chain. Software can read out a signature by reading the MISR Data
    // Out bit  
    // after each of a series of one-bit shift operations using the MISR Shift control
    // bit 
    //         
    // 
    // Bits[19:8], RO_V, default = 0x0
    //
    UINTX aciodata : 12;
    //
    // Spare1
    //         
    // 
    // Bits[28:20], RW_L, default = 0x0
    //
    UINTX spare1 : 9;
    //
    // First PiClk Sweep bit
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ddrsweepselect0 : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddrsweepselect1 : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddraciomodesel : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDACIOLB_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDTRAINING_CKE_DDRIOHI_REG                  0x0000082C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained PiCode Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX trainingoffset : 6;
    //
    // Spare
    //         
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX spare0 : 2;
    //
    // bits13:6 unused
    //                      bit5 output of phase detector for I/O Pair 0
    //                      bit4 output of phase detector for I/O Pair 1
    //                      bit3 output of phase detector for I/O Pair 2
    //                      bit2 output of phase detector for I/O Pair 3
    //                      bit1 output of phase detector for I/O Pair 4
    //                      bit0 output of phase detector for I/O Pair 5 (only on cmdctla
    // FUBs) 
    //         
    // 
    // Bits[21:8], RO_V, default = 0x0
    //
    UINTX xoverphasedet : 14;
    //
    // Offset added to PiCode. Obtained via xover calibration such that ClkPi aligns
    // with grid clock when PiCode=0. 
    // 
    // Bits[27:22], RW_L, default = 0x0
    //
    UINTX trainingoffset2 : 6;
    //
    // Spare
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare1 : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDTRAINING_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CKE_DDRIOHI_REG                 0x00000830
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdOutputEnable
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdoutputensel : 12;
    //
    // Select CompCode between cmd or ctl
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX selectcompcode : 1;
    //
    // Imode coef
    // 
    // Bits[15:13], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CmdHighCtlSelfRefresh
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX eqlowpowerdisable : 1;
    //
    // 1: Center Tap Termination for DDR3; 0: Vddq Termination for DDR4/VMSE
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Static leg enable
    // 
    // Bits[23:22], RW_L, default = 0x3
    //
    UINTX dqstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[25:24], RW_L, default = 0x3
    //
    UINTX odtstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xtalklowpower : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //  
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled  
    //             for deemphasized, and so on.
    //         
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX txeq : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING2_CKE_DDRIOHI_REG                 0x00000834
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode3 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay3 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel3 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode4 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay4 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel4 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode5 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay5 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel5 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING2_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING3_CKE_DDRIOHI_REG                 0x00000838
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode6 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay6 : 2;
    //
    // Selects the Xover Phase
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel6 : 1;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING3_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLMISRMASK_CKE_DDRIOHI_REG                  0x0000083C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Masking out Miser during VMSE
    // 
    // Bits[11:0], RW_LB, default = 0x0
    //
    UINTX ctlmisrmask : 12;
    //
    // First PiClk Sweep bit
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect0qnnnh : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect1qnnnh : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX ddraciomodeselqnnnh : 1;
    //
    // Spare
    // 
    // Bits[31:15], RW_LB, default = 0x0
    //
    UINTX spare : 17;
  } Bits;
  UINTX Data;
} DDRCRCTLMISRMASK_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CKE_DDRIOHI_REG                0x00000840
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description:
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode
    //         PanicVoltage     21:18  Unsigned integer controlling the voltage error
    // on VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP1_CKE_DDRIOHI_REG                     0x00000844
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VT Comp Values
    // 
    // Bits[4:0], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[14:5], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[24:15], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
    //
    // Spare
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP1_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL1_CKE_DDRIOHI_REG               0x00000848
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  BDX-specific extended control signal. 
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl : 8;
    //
    // spare.
    // 
    // Bits[31:8], RW_L, default = 0x0
    //
    UINTX spare : 24;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL1_CKE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKRANKSUSED_DDRIOHI_REG                     0x00000A00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables output buffers, PI clocks and output datapaths for this rank
    // 
    // Bits[3:0], RW_L, default = 0xF
    //
    UINTX ranken : 4;
    //
    // Spare
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX spare1 : 4;
    //
    // DDRT Mode Clk1 Enable
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX ddrtclk1en : 1;
    //
    // DDRT Mode Clk3 Enable
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX ddrtclk3en : 1;
    //
    // DDRT Mode Clk0 Enable
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX ddrtclk0en : 1;
    //
    // DDRT Mode Clk2 Enable
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX ddrtclk2en : 1;
    //
    // Asserted during the Read ID fine training sub-step Causes the sampled value for
    // the Read ID signal to be placed in a results register within the DDRIO fub 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX ddrttraining : 1;
    //
    // Segments to enable for driving (inverse for ODT)
    // 
    // Bits[15:13], RW_L, default = 0x7
    //
    UINTX drvsegen : 3;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // XNOR with DAlign
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX clkdealignbitqnnnh : 1;
    //
    // Fifo Point separation bit
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX fifoptctlqnnnh : 1;
    //
    // spare
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // ClkCtleCapEn for Clk RX buffer
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX clkctlecapen : 2;
    //
    // ClkCtleResEn for Clk RX buffer
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX clkctleresen : 2;
    //
    // ClkRxOffsetCtlEnable or RxOffsetCodeUngate for Clk RX buffer
    // 
    // Bits[24:24], RW_L, default = 0x0
    //
    UINTX rxoffsetcodeungate : 1;
    //
    // RefD0Clk
    // 
    // Bits[30:25], RW_L, default = 0x0
    //
    UINTX refpiclk : 6;
    //
    // Ddr CLK fub vertical bump placement enable for RGT/FNV
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddrclkverticalbumpplacmenten : 1;
  } Bits;
  UINTX Data;
} DDRCRCLKRANKSUSED_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKCOMP_CLK_DDRIOHI_REG                      0x00000A04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scomp : 5;
    //
    // Tco Comp Value
    // 
    // Bits[11:5], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // LevelShift Comp Value. Not unsed, controlled via MsgCh only.
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCLKCOMP_CLK_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKCOMPOFFSET_CLK_DDRIOHI_REG                0x00000A08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value. Signed. per fub, added onto FSM value.
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 4;
    //
    // Tco Comp Offset Value. Signed. per fub, added onto FSM value.
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value. Signed. per fub, added onto FSM value.
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // BDX change:  This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[16:16], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
    //
    // ClkPcasBiasClosedLoopEn for Clk Rx buf
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX clkpcasbiasclosedloopen : 1;
    //
    // ClkRxBiasSelQnnnH for Clk Rx Buf
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX clkrxbiasselqnnnh : 1;
    //
    // ClkRxEq for Clk Rx Buf
    // 
    // Bits[21:19], RW_L, default = 0x0
    //
    UINTX clkrxeq : 3;
    //
    // DdrClkRxBiasCtl for Clk Rx Buf
    // 
    // Bits[24:22], RW_L, default = 0x0
    //
    UINTX ddrclkrxbiasctl : 3;
    //
    // ForceClkBiason for Clk Rx Buf
    // 
    // Bits[25:25], RW_L, default = 0x1
    //
    UINTX forceclkbiason : 1;
    //
    // SaOffsetTrainTxOn or ClkSaOffsetTrainQnnnH for Clk Rx Buf
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // DdrClkRxBiasFoldedLegTrim for Clk Rx Buf
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX ddrclkrxbiasfoldedlegtrim : 2;
    //
    // DdrClkRxBiasGcnComp for Clk Rx Buf
    // 
    // Bits[30:29], RW_L, default = 0x0
    //
    UINTX ddrclkrxbiasgcncomp : 2;
    //
    // control the DdrVrefSelDQQnnnH pin on the ddrvrefint generator
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX clkvrefpgen : 1;
  } Bits;
  UINTX Data;
} DDRCRCLKCOMPOFFSET_CLK_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKPICODE_DDRIOHI_REG                        0x00000A0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Pi Setting, Rank 0
    //                      [5:0] - Pi setting for xxDDR_CLK_P/N[0]
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX pisettingrank0 : 6;
    //
    // Pi Logic Delay, Rank 0, delays CLK by an extra qclk cycle
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX pilogicdelayrank0 : 1;
    //
    // unused
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // Pi Setting, Rank 1
    //                      [5:0] - Pi setting for xxDDR_CLK_P/N[1]
    // 
    // Bits[13:8], RW_L, default = 0x0
    //
    UINTX pisettingrank1 : 6;
    //
    // Pi Logic Delay, Rank 1
    // 
    // Bits[14:14], RW_L, default = 0x0
    //
    UINTX pilogicdelayrank1 : 1;
    //
    // not used
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX spare1 : 1;
    //
    // Pi Setting, Rank 2
    //                      [5:0] - Pi setting for xxDDR_CLK_P/N[2]
    // 
    // Bits[21:16], RW_L, default = 0x0
    //
    UINTX pisettingrank2 : 6;
    //
    // Pi Logic Delay, Rank 2
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX pilogicdelayrank2 : 1;
    //
    // not used
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // Pi Setting, Rank 3
    //                      [5:0] - Pi setting for xxDDR_CLK_P/N[3]
    // 
    // Bits[29:24], RW_L, default = 0x0
    //
    UINTX pisettingrank3 : 6;
    //
    // Pi Logic Delay, Rank 3
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX pilogicdelayrank3 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX spare3 : 1;
  } Bits;
  UINTX Data;
} DDRCRCLKPICODE_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKCONTROLS_DDRIOHI_REG                      0x00000A10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Phased based xtalk cancellation is enabled, set this to delay cmd to maintain
    // constant Tcwl. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX ddrphasextalkenableqnnnh : 1;
    //
    // Enable Visa debug bus LCB for CLK fub
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // enable PiRef clock divider in xover
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX pirefclkdivenable : 1;
    //
    // Xover Select between grid-PiRef and PiRef-PiN
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX xoveropmode : 1;
    //
    // not used
    // 
    // Bits[6:4], RW_L, default = 0x0
    //
    UINTX clkodtpdnsegen : 3;
    //
    // Forces the CLK transmitter on, overriding any power downs 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Forces on all PI enables and the LCB enables in the AFE fubs.  Does not force
    // on D0 PI enable or override weaklock mode. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX intclkon : 1;
    //
    // not used 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX repclkon : 1;
    //
    // Controls IO Loopback.  Ctl[1] enables IOLB mode and Ctl[0] controls if this is
    // a Setup(0) or Hold(1) test 
    // 
    // Bits[11:10], RW_L, default = 0x0
    //
    UINTX iolbctl : 2;
    //
    // Forces the driver in ODT mode, where both the pullup and pulldown are enabled.
    //  Used for Rstray testing 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // not used
    // 
    // Bits[15:13], RW_L, default = 0x3
    //
    UINTX odtpupsegen : 3;
    //
    // set to drive DC on xxCLK during P6 and S3 if DDR3 + RDIMM is populated
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX is_rdimm : 1;
    //
    // static leg enable
    // 
    // Bits[18:17], RW_L, default = 0x3
    //
    UINTX statlegen : 2;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // 1: Center Tap Termination for DDR3; 0: Vddq Termination for DDR4/Intel SMI 2
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // IOLB Vref Control.  2s compliment encoding from 1/3 Vdd to 2/3 Vdd with step size
    // of Vdd/192 (7.8mV) 
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX rxvref : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX halflsbbit : 1;
    //
    // notused
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // level shift hold enable:
    //                      Holds the HV control values and power down the level shifters.
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
  } Bits;
  UINTX Data;
} DDRCRCLKCONTROLS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADC_CLK_DDRIOHI_REG                   0x00000A14
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADC_CLK_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKTRAINING_DDRIOHI_REG                      0x00000A1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained PiCode Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX trainingoffset : 6;
    //
    // IODirectionValid
    //         
    // 
    // Bits[6:6], RW_L, default = 0x1
    //
    UINTX iodirectionvalid : 1;
    //
    // Spare
    //         
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // P Clock Buffer Xover Phase Detect
    //         
    // 
    // Bits[11:8], RO_V, default = 0x0
    //
    UINTX pclkxoverphasedet : 4;
    //
    // N Clock Buffer Xover Phase Detect
    //         
    // 
    // Bits[15:12], RO_V, default = 0x0
    //
    UINTX nclkxoverphasedet : 4;
    //
    // spare
    // 
    // Bits[31:16], RW_L, default = 0x0
    //
    UINTX spare2 : 16;
  } Bits;
  UINTX Data;
} DDRCRCLKTRAINING_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKACIOLB_DDRIOHI_REG                        0x00000A20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACIO Enable
    // The MISR Logic Enable control bit is a master switch that enables the clock to
    // all of the logic  
    // and circuits that are specific to the command/control ACIO loopback feature. The
    // MISR Logic Enable bit  
    // must be set to one whenever the loopback/MISR logic needs to be used. It should
    // be set to zero otherwise,  
    // so that clock power is not wasted.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX acioen : 1;
    //
    // ACIO Even Data Parallel Out
    //         
    // 
    // Bits[8:1], RO_V, default = 0x0
    //
    UINTX acioevendata : 8;
    //
    // ACIO Odd Data Parallel Out
    //         
    // 
    // Bits[16:9], RO_V, default = 0x0
    //
    UINTX acioodddata : 8;
    //
    // CLK Polarity.  XORed with even (inverse with Odd)
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX acioclkpolarity : 1;
    //
    // Independant ClkRxVocSel or ClkRxVocPassGateEn for Full RX receiver 
    // 
    // Bits[25:18], RW_L, default = 0x0
    //
    UINTX rxvocpassgateen : 8;
    //
    // Spare1
    // 
    // Bits[28:26], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // First PiClk Sweep bit
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ddrsweepselect0 : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddrsweepselect1 : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddraciomodesel : 1;
  } Bits;
  UINTX Data;
} DDRCRCLKACIOLB_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRDDRTTRAINRESULT_DDRIOHI_REG                  0x00000A24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit 7 CKP3 early Read ID training result (Even) 
    //                      Bit 6 CKP3 early Read ID training result (Odd)
    //                      Bit 5 CKN3 early Read ID training result (Even)
    //                      Bit 4 CKN3 early Read ID training result (Odd)
    //                      Bit 3 CKP1 early Read ID training result (Even)
    //                      Bit 2 CKP1 early Read ID training result (Odd)
    //                      Bit 1 CKN1 early Read ID training result (Even)
    //                      Bit 0 CKN1 early Read ID training result (Odd)
    //                      CKP3/CKN3  slot 1 read ID bits   
    //                      CKP1/CKN1   slot 0 read ID bits
    //                      Read ID training result (8 bits) Result of sampling on each
    // Read ID input signal, and for even and odd cycles If the even/odd results are
    // recorded in separate bitfields, no need to add logic to only capture every other
    // sample, since the data is available for the BIOS to make a decision. 
    //         
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX evenoddsamples : 8;
    //
    // spare 
    // 
    // Bits[31:8], RW_L, default = 0x0
    //
    UINTX spare : 24;
  } Bits;
  UINTX Data;
} DDRCRDDRTTRAINRESULT_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CMDN_DDRIOHI_REG                     0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value, Normally updated by Comp FSM via CompBus. can be overriden via message
    // channel if periodical retrain is disabled. 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value, Normally updated by Comp FSM via CompBus. can be overriden via
    // message channel if periodical retrain is disabled. 
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // not used
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CMDN_DDRIOHI_REG               0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Enable DDRT Parity in CMDCTL
    // 
    // Bits[28:17], RW_L, default = 0x0
    //
    UINTX ddrcmdctlrx_en : 12;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING_CMDN_DDRIOHI_REG                 0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode0 : 6;
    //
    // Cmd Pi Logic Delay - add 1 qclk cycle delay.
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay0 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel0 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode1 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay1 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel1 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode2 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay2 : 2;
    //
    // not used
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel2 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CMDN_DDRIOHI_REG                 0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Phased based xtalk cancellation is enabled, set this to delay cmd to maintain
    // constant Tcwl. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX ddrphasextalkenableqnnnh : 1;
    //
    // Enable Visa debug bus LCB for CMD fub
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // enable PiRef clock divider in xover
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX pirefclkdivenable : 1;
    //
    // Xover Select between grid-PiRef and PiRef-PiN
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX xoveropmode : 1;
    //
    // On weak lock exit, controls how long the feedback to the phase detector is masked:
    // {0: 1 qclk (required for delayline latency), 1: 2 qclk, 2: 3 qclk, 3: 4 qclk}
    // 
    // Bits[5:4], RW_L, default = 0x0
    //
    UINTX dllmask : 2;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Forces the CMD transmitter on, overriding any power downs
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Forces on all PI enables and the LCB enables in the AFE fubs.  Does not force
    // on D0 PI enable or override weaklock mode. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX intclkon : 1;
    //
    // not used 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX repclkon : 1;
    //
    // Controls IO Loopback.  Ctl[1] enables IOLB mode and Ctl[0] controls if this is
    // a Setup(0) or Hold(1) test 
    // 
    // Bits[11:10], RW_L, default = 0x0
    //
    UINTX iolbctl : 2;
    //
    // Forces the driver in ODT mode, where both the pullup and pulldown are enabled.
    //  Used for Rstray testing 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // not used
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX cmdtxeq : 2;
    //
    // Controls the number of segments enabled during the early warning weak drive: {0:
    // All Enabled, 1: Enable Seg[4], 2: Enable Seg[4:3], 3: Enable Seg[4:2]} 
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX earlyweakdrive : 2;
    //
    // not used
    //         
    // 
    // Bits[18:17], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
    //
    // not used
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // IOLB Vref Control.  2s compliment encoding from 1/3 Vdd to 2/3 Vdd with step size
    // of Vdd/192 (7.8mV) 
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX rxvref : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX halflsbbit : 1;
    //
    //  Vref Disable
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vrefdisable : 1;
    //
    // Ddr4 Mode Enable, set to 1 in CMD2 (Func:5.Addr:C00 and Func:7.Addr:C00) fub to
    // bypass extra delay on parity bit 
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddr4modeenable : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS2_CMDN_DDRIOHI_REG                0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdCtl RxVoSel or RxVocPassGateEn  for CmdCtl Receiver
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdrxvocpassgateen : 12;
    //
    // FNV Cmd Power Down
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX fnvcrcmdpowerdown : 1;
    //
    // FNV Cr Cmd Is CKE
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX fnvcrcmdiscke : 6;
    //
    // FNV Cmd Sample Enable
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX fnvcmdsampleen : 1;
    //
    // FNV DDR/PI Bypass Enable
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX fnvddrcrdllpibypassen : 1;
    //
    // Enable finer vref resolution in ddr4
    //         
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // BDX change : This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[22:22], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
    //
    // CmdRxBiasSel for Cmd Receiver
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX cmdrxbiassel : 1;
    //
    // ForceCmdBiason for Cmd Receiver
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX forcecmdbiason : 1;
    //
    // bypass ddrcmdctl xover for FNV
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX fnvcmdcrxoverbypassen : 1;
    //
    // CmdCtl Buffer CtleCapEn
    // 
    // Bits[27:26], RW_L, default = 0x0
    //
    UINTX cmdctlecapen : 2;
    //
    // CmdCtl Buffer CtleResEn
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX cmdctleresen : 2;
    //
    // RxOffsetCodeUngate or CmdRxOffsetCtlEnable for CmdCtl Rx buffer
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX rxoffsetcodeungate : 1;
    //
    // SaOffsetTrainTxOn or CmdSaOffsetTrain for Cmd buf
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS2_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMP_CMDN_DDRIOHI_REG                     0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // LevelShift Comp Value
    // 
    // Bits[27:25], RW_L, default = 0x0
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMP_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMPOFFSET_CMDN_DDRIOHI_REG               0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdctlbufsel : 6;
    //
    // Is the Direction (RX/TX Valid)
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX iodirectionvalid : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMPOFFSET_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CMDN_DDRIOHI_REG                0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Drive strength enable for CmdBuf/CtlBuf.
    // 
    // Bits[4:0], RW_L, default = 0x1F
    //
    UINTX bufdrvsegen : 5;
    //
    // control the DdrVrefSelDQQnnnH pin on the ddrvrefint generator
    // 
    // Bits[5:5], RW_L, default = 0x1
    //
    UINTX cmdvrefpgen : 1;
    //
    // OdtStrength 
    // 
    // Bits[6:6], RW_L, default = 0x1
    //
    UINTX odtstrength : 1;
    //
    // spare1
    // 
    // Bits[8:7], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Invert DAlign 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX divby2alignctl : 1;
    //
    // select qclk for cmdxover instead of Dclk 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX divby2disable : 1;
    //
    // ODTDis for Cmd and Ctl buf
    // 
    // Bits[22:11], RW_L, default = 0x0
    //
    UINTX odten : 12;
    //
    // CmdRefClk
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX cmdrefpiclkdelay : 6;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLRANKSUSED_CMDN_DDRIOHI_REG                0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables output buffers for ctlbufpair 0 to ctlbufpair6 , PI clocks and output
    // datapaths for this rank 
    // 
    // Bits[5:0], RW_L, default = 0x3F
    //
    UINTX ranken : 6;
    //
    // Spare
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX spare : 6;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // used to compensate the GCN skew. The GCN skew information should be
    //           extracted by reading and analyzing the final Rcomp code value. The target
    // spec 
    //           is to categorize the GCN skew in 3 process condition (mainly slow, fast,
    // typical). 
    //           (one example can be just reading the 2 MLS bit of Rcomp code and determine
    // if the 
    //           GCN is slow, fast or typical). The gcncomp is used for CTLE.
    //           11: gcn in slow corner
    //           10: gcn in typical corner
    //           01: gcn in fast corner
    //         
    // 
    // Bits[14:13], RW_L, default = 0x2
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Imode bias DFx leg control
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // Imode bias control
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX imodebiashighcm : 1;
    //
    // Rx bias Sel
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // CmdRxEqQnnnL for RX CmdCtl Buf 
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX cmdrxeqqnnnl : 3;
    //
    // spare
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // CmdRxBiasCtl for RX biasgen 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasctl : 3;
    //
    // CmdPcasBiasClosedLoopEnQnnnH for RX biasgen 
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX cmdpcasbiasclosedloopen : 1;
    //
    // DdrCmdRxBiasFoldedLegTrim for RX biasgen 
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasfoldedlegtrim : 2;
    //
    // spare1
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare2 : 2;
  } Bits;
  UINTX Data;
} DDRCRCTLRANKSUSED_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADC_CMDN_DDRIOHI_REG                  0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADC_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDACIOLB_CMDN_DDRIOHI_REG                   0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACIO Enable
    // The MISR Logic Enable control bit is a master switch that enables the clock to
    // all of the logic  
    // and circuits that are specific to the command/control ACIO loopback feature. The
    // MISR Logic Enable bit  
    // must be set to one whenever the loopback/MISR logic needs to be used. It should
    // be set to zero otherwise,  
    // so that clock power is not wasted.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX acioen : 1;
    //
    // ACIO MISR Clear
    // The MISR Clear control bit resets the entire shift register to all zero. 
    // The reset is triggered by the zero-to-one transition of the MISR Clear bit, 
    // and after the clear operation is done, the MISR Operation Done bit is set to one.
    //         
    // 
    // Bits[1:1], RW_V, default = 0x0
    //
    UINTX acioclear : 1;
    //
    // ACIO MISR Auto Start
    // The MISR Auto Start control bit arms the control logic to start signature accumulation
    // when it detects  
    // the first non-zero value on the trigger lane. Once the signature collection has
    // been started,  
    // the MISR Auto Start bit is automatically cleared, but the MISR Operation Done
    // bit is set. 
    //         
    // 
    // Bits[2:2], RW_V, default = 0x0
    //
    UINTX acioautostart : 1;
    //
    // ACIO MISR Manual Start
    // The MISR Manual Start bit is a control bit that starts signature collection immediately.
    //  
    // In this case, the control logic does not consider the state of the trigger lane.
    // Signature collection is triggered exclusively by the zero-to-one transition of
    // the MISR Manual Start bit.  
    // Once signature collection is started, the MISR Manual Start bit is automatically
    // cleared,  
    // but the MISR Operation Done bit is set.
    //         
    // 
    // Bits[3:3], RW_V, default = 0x0
    //
    UINTX aciomanustart : 1;
    //
    // ACIO MISR Busy indication
    // The MISR Busy bit indicates that signature collection is running. 
    // It is set when the signature collection timer starts and cleared when the timer
    // stops. 
    //         
    // 
    // Bits[4:4], RO_V, default = 0x0
    //
    UINTX aciomisrbusy : 1;
    //
    // ACIO MISR Operation Done indication
    // The MISR Operation Done bit is set to one whenever a clear, start or shift operation
    // has occurred.  
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[5:5], RW1C, default = 0x0
    //
    UINTX aciomisropdone : 1;
    //
    // ACIO MISR Collection Done indication
    // The MISR Collection Done bit is set to one whenever a signature collection 
    // phase finishes, that is when the signature collection timer stops. 
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[6:6], RW1C, default = 0x0
    //
    UINTX aciomisrcollectdone : 1;
    //
    // Spare0
    //         
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // ACIOData Parallel Out
    // The MISR Data Out bit is a read-only bit that's essentially one bit in the MISR's
    // shift  
    // (or rotate) chain. Software can read out a signature by reading the MISR Data
    // Out bit  
    // after each of a series of one-bit shift operations using the MISR Shift control
    // bit 
    //         
    // 
    // Bits[19:8], RO_V, default = 0x0
    //
    UINTX aciodata : 12;
    //
    // Spare1
    //         
    // 
    // Bits[28:20], RW_L, default = 0x0
    //
    UINTX spare1 : 9;
    //
    // First PiClk Sweep bit
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ddrsweepselect0 : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddrsweepselect1 : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddraciomodesel : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDACIOLB_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDTRAINING_CMDN_DDRIOHI_REG                 0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained PiCode Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX trainingoffset : 6;
    //
    // Spare
    //         
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX spare0 : 2;
    //
    // bits13:6 unused
    //                      bit5 output of phase detector for I/O Pair 0
    //                      bit4 output of phase detector for I/O Pair 1
    //                      bit3 output of phase detector for I/O Pair 2
    //                      bit2 output of phase detector for I/O Pair 3
    //                      bit1 output of phase detector for I/O Pair 4
    //                      bit0 output of phase detector for I/O Pair 5 (only on cmdctla
    // FUBs) 
    //         
    // 
    // Bits[21:8], RO_V, default = 0x0
    //
    UINTX xoverphasedet : 14;
    //
    // Offset added to PiCode. Obtained via xover calibration such that ClkPi aligns
    // with grid clock when PiCode=0. 
    // 
    // Bits[27:22], RW_L, default = 0x0
    //
    UINTX trainingoffset2 : 6;
    //
    // Spare
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare1 : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDTRAINING_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CMDN_DDRIOHI_REG                0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdOutputEnable
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdoutputensel : 12;
    //
    // Select CompCode between cmd or ctl
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX selectcompcode : 1;
    //
    // Imode coef
    // 
    // Bits[15:13], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CmdHighCtlSelfRefresh
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX eqlowpowerdisable : 1;
    //
    // 1: Center Tap Termination for DDR3; 0: Vddq Termination for DDR4/VMSE
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Static leg enable
    // 
    // Bits[23:22], RW_L, default = 0x3
    //
    UINTX dqstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[25:24], RW_L, default = 0x3
    //
    UINTX odtstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xtalklowpower : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //  
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled  
    //             for deemphasized, and so on.
    //         
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX txeq : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING2_CMDN_DDRIOHI_REG                0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode3 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay3 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel3 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode4 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay4 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel4 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode5 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay5 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel5 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING2_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING3_CMDN_DDRIOHI_REG                0x00000638
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode6 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay6 : 2;
    //
    // Selects the Xover Phase
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel6 : 1;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING3_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLMISRMASK_CMDN_DDRIOHI_REG                 0x0000063C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Masking out Miser during VMSE
    // 
    // Bits[11:0], RW_LB, default = 0x0
    //
    UINTX ctlmisrmask : 12;
    //
    // First PiClk Sweep bit
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect0qnnnh : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect1qnnnh : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX ddraciomodeselqnnnh : 1;
    //
    // Spare
    // 
    // Bits[31:15], RW_LB, default = 0x0
    //
    UINTX spare : 17;
  } Bits;
  UINTX Data;
} DDRCRCTLMISRMASK_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CMDN_DDRIOHI_REG               0x00000640
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description:
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode
    //         PanicVoltage     21:18  Unsigned integer controlling the voltage error
    // on VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP1_CMDN_DDRIOHI_REG                    0x00000644
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VT Comp Values
    // 
    // Bits[4:0], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[14:5], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[24:15], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
    //
    // Spare
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP1_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL1_CMDN_DDRIOHI_REG              0x00000648
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  BDX-specific extended control signal. 
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl : 8;
    //
    // spare.
    // 
    // Bits[31:8], RW_L, default = 0x0
    //
    UINTX spare : 24;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL1_CMDN_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CMDS_DDRIOHI_REG                     0x00000C00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value, Normally updated by Comp FSM via CompBus. can be overriden via message
    // channel if periodical retrain is disabled. 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value, Normally updated by Comp FSM via CompBus. can be overriden via
    // message channel if periodical retrain is disabled. 
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // not used
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CMDS_DDRIOHI_REG               0x00000C04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Enable DDRT Parity in CMDCTL
    // 
    // Bits[28:17], RW_L, default = 0x0
    //
    UINTX ddrcmdctlrx_en : 12;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING_CMDS_DDRIOHI_REG                 0x00000C08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode0 : 6;
    //
    // Cmd Pi Logic Delay - add 1 qclk cycle delay.
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay0 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel0 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode1 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay1 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel1 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode2 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay2 : 2;
    //
    // not used
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel2 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CMDS_DDRIOHI_REG                 0x00000C0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Phased based xtalk cancellation is enabled, set this to delay cmd to maintain
    // constant Tcwl. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX ddrphasextalkenableqnnnh : 1;
    //
    // Enable Visa debug bus LCB for CMD fub
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // enable PiRef clock divider in xover
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX pirefclkdivenable : 1;
    //
    // Xover Select between grid-PiRef and PiRef-PiN
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX xoveropmode : 1;
    //
    // On weak lock exit, controls how long the feedback to the phase detector is masked:
    // {0: 1 qclk (required for delayline latency), 1: 2 qclk, 2: 3 qclk, 3: 4 qclk}
    // 
    // Bits[5:4], RW_L, default = 0x0
    //
    UINTX dllmask : 2;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Forces the CMD transmitter on, overriding any power downs
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Forces on all PI enables and the LCB enables in the AFE fubs.  Does not force
    // on D0 PI enable or override weaklock mode. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX intclkon : 1;
    //
    // not used 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX repclkon : 1;
    //
    // Controls IO Loopback.  Ctl[1] enables IOLB mode and Ctl[0] controls if this is
    // a Setup(0) or Hold(1) test 
    // 
    // Bits[11:10], RW_L, default = 0x0
    //
    UINTX iolbctl : 2;
    //
    // Forces the driver in ODT mode, where both the pullup and pulldown are enabled.
    //  Used for Rstray testing 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // not used
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX cmdtxeq : 2;
    //
    // Controls the number of segments enabled during the early warning weak drive: {0:
    // All Enabled, 1: Enable Seg[4], 2: Enable Seg[4:3], 3: Enable Seg[4:2]} 
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX earlyweakdrive : 2;
    //
    // not used
    //         
    // 
    // Bits[18:17], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
    //
    // not used
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // IOLB Vref Control.  2s compliment encoding from 1/3 Vdd to 2/3 Vdd with step size
    // of Vdd/192 (7.8mV) 
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX rxvref : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX halflsbbit : 1;
    //
    //  Vref Disable
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vrefdisable : 1;
    //
    // Ddr4 Mode Enable, set to 1 in CMD2 (Func:5.Addr:C00 and Func:7.Addr:C00) fub to
    // bypass extra delay on parity bit 
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddr4modeenable : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS2_CMDS_DDRIOHI_REG                0x00000C10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdCtl RxVoSel or RxVocPassGateEn  for CmdCtl Receiver
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdrxvocpassgateen : 12;
    //
    // FNV Cmd Power Down
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX fnvcrcmdpowerdown : 1;
    //
    // FNV Cr Cmd Is CKE
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX fnvcrcmdiscke : 6;
    //
    // FNV Cmd Sample Enable
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX fnvcmdsampleen : 1;
    //
    // FNV DDR/PI Bypass Enable
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX fnvddrcrdllpibypassen : 1;
    //
    // Enable finer vref resolution in ddr4
    //         
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // BDX change : This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[22:22], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
    //
    // CmdRxBiasSel for Cmd Receiver
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX cmdrxbiassel : 1;
    //
    // ForceCmdBiason for Cmd Receiver
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX forcecmdbiason : 1;
    //
    // bypass ddrcmdctl xover for FNV
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX fnvcmdcrxoverbypassen : 1;
    //
    // CmdCtl Buffer CtleCapEn
    // 
    // Bits[27:26], RW_L, default = 0x0
    //
    UINTX cmdctlecapen : 2;
    //
    // CmdCtl Buffer CtleResEn
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX cmdctleresen : 2;
    //
    // RxOffsetCodeUngate or CmdRxOffsetCtlEnable for CmdCtl Rx buffer
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX rxoffsetcodeungate : 1;
    //
    // SaOffsetTrainTxOn or CmdSaOffsetTrain for Cmd buf
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS2_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMP_CMDS_DDRIOHI_REG                     0x00000C14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // LevelShift Comp Value
    // 
    // Bits[27:25], RW_L, default = 0x0
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMP_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMPOFFSET_CMDS_DDRIOHI_REG               0x00000C18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdctlbufsel : 6;
    //
    // Is the Direction (RX/TX Valid)
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX iodirectionvalid : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMPOFFSET_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CMDS_DDRIOHI_REG                0x00000C1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Drive strength enable for CmdBuf/CtlBuf.
    // 
    // Bits[4:0], RW_L, default = 0x1F
    //
    UINTX bufdrvsegen : 5;
    //
    // control the DdrVrefSelDQQnnnH pin on the ddrvrefint generator
    // 
    // Bits[5:5], RW_L, default = 0x1
    //
    UINTX cmdvrefpgen : 1;
    //
    // OdtStrength 
    // 
    // Bits[6:6], RW_L, default = 0x1
    //
    UINTX odtstrength : 1;
    //
    // spare1
    // 
    // Bits[8:7], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Invert DAlign 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX divby2alignctl : 1;
    //
    // select qclk for cmdxover instead of Dclk 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX divby2disable : 1;
    //
    // ODTDis for Cmd and Ctl buf
    // 
    // Bits[22:11], RW_L, default = 0x0
    //
    UINTX odten : 12;
    //
    // CmdRefClk
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX cmdrefpiclkdelay : 6;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLRANKSUSED_CMDS_DDRIOHI_REG                0x00000C20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables output buffers for ctlbufpair 0 to ctlbufpair6 , PI clocks and output
    // datapaths for this rank 
    // 
    // Bits[5:0], RW_L, default = 0x3F
    //
    UINTX ranken : 6;
    //
    // Spare
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX spare : 6;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // used to compensate the GCN skew. The GCN skew information should be
    //           extracted by reading and analyzing the final Rcomp code value. The target
    // spec 
    //           is to categorize the GCN skew in 3 process condition (mainly slow, fast,
    // typical). 
    //           (one example can be just reading the 2 MLS bit of Rcomp code and determine
    // if the 
    //           GCN is slow, fast or typical). The gcncomp is used for CTLE.
    //           11: gcn in slow corner
    //           10: gcn in typical corner
    //           01: gcn in fast corner
    //         
    // 
    // Bits[14:13], RW_L, default = 0x2
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Imode bias DFx leg control
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // Imode bias control
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX imodebiashighcm : 1;
    //
    // Rx bias Sel
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // CmdRxEqQnnnL for RX CmdCtl Buf 
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX cmdrxeqqnnnl : 3;
    //
    // spare
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // CmdRxBiasCtl for RX biasgen 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasctl : 3;
    //
    // CmdPcasBiasClosedLoopEnQnnnH for RX biasgen 
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX cmdpcasbiasclosedloopen : 1;
    //
    // DdrCmdRxBiasFoldedLegTrim for RX biasgen 
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasfoldedlegtrim : 2;
    //
    // spare1
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare2 : 2;
  } Bits;
  UINTX Data;
} DDRCRCTLRANKSUSED_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADC_CMDS_DDRIOHI_REG                  0x00000C24
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADC_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDACIOLB_CMDS_DDRIOHI_REG                   0x00000C28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACIO Enable
    // The MISR Logic Enable control bit is a master switch that enables the clock to
    // all of the logic  
    // and circuits that are specific to the command/control ACIO loopback feature. The
    // MISR Logic Enable bit  
    // must be set to one whenever the loopback/MISR logic needs to be used. It should
    // be set to zero otherwise,  
    // so that clock power is not wasted.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX acioen : 1;
    //
    // ACIO MISR Clear
    // The MISR Clear control bit resets the entire shift register to all zero. 
    // The reset is triggered by the zero-to-one transition of the MISR Clear bit, 
    // and after the clear operation is done, the MISR Operation Done bit is set to one.
    //         
    // 
    // Bits[1:1], RW_V, default = 0x0
    //
    UINTX acioclear : 1;
    //
    // ACIO MISR Auto Start
    // The MISR Auto Start control bit arms the control logic to start signature accumulation
    // when it detects  
    // the first non-zero value on the trigger lane. Once the signature collection has
    // been started,  
    // the MISR Auto Start bit is automatically cleared, but the MISR Operation Done
    // bit is set. 
    //         
    // 
    // Bits[2:2], RW_V, default = 0x0
    //
    UINTX acioautostart : 1;
    //
    // ACIO MISR Manual Start
    // The MISR Manual Start bit is a control bit that starts signature collection immediately.
    //  
    // In this case, the control logic does not consider the state of the trigger lane.
    // Signature collection is triggered exclusively by the zero-to-one transition of
    // the MISR Manual Start bit.  
    // Once signature collection is started, the MISR Manual Start bit is automatically
    // cleared,  
    // but the MISR Operation Done bit is set.
    //         
    // 
    // Bits[3:3], RW_V, default = 0x0
    //
    UINTX aciomanustart : 1;
    //
    // ACIO MISR Busy indication
    // The MISR Busy bit indicates that signature collection is running. 
    // It is set when the signature collection timer starts and cleared when the timer
    // stops. 
    //         
    // 
    // Bits[4:4], RO_V, default = 0x0
    //
    UINTX aciomisrbusy : 1;
    //
    // ACIO MISR Operation Done indication
    // The MISR Operation Done bit is set to one whenever a clear, start or shift operation
    // has occurred.  
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[5:5], RW1C, default = 0x0
    //
    UINTX aciomisropdone : 1;
    //
    // ACIO MISR Collection Done indication
    // The MISR Collection Done bit is set to one whenever a signature collection 
    // phase finishes, that is when the signature collection timer stops. 
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[6:6], RW1C, default = 0x0
    //
    UINTX aciomisrcollectdone : 1;
    //
    // Spare0
    //         
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // ACIOData Parallel Out
    // The MISR Data Out bit is a read-only bit that's essentially one bit in the MISR's
    // shift  
    // (or rotate) chain. Software can read out a signature by reading the MISR Data
    // Out bit  
    // after each of a series of one-bit shift operations using the MISR Shift control
    // bit 
    //         
    // 
    // Bits[19:8], RO_V, default = 0x0
    //
    UINTX aciodata : 12;
    //
    // Spare1
    //         
    // 
    // Bits[28:20], RW_L, default = 0x0
    //
    UINTX spare1 : 9;
    //
    // First PiClk Sweep bit
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ddrsweepselect0 : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddrsweepselect1 : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddraciomodesel : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDACIOLB_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDTRAINING_CMDS_DDRIOHI_REG                 0x00000C2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained PiCode Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX trainingoffset : 6;
    //
    // Spare
    //         
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX spare0 : 2;
    //
    // bits13:6 unused
    //                      bit5 output of phase detector for I/O Pair 0
    //                      bit4 output of phase detector for I/O Pair 1
    //                      bit3 output of phase detector for I/O Pair 2
    //                      bit2 output of phase detector for I/O Pair 3
    //                      bit1 output of phase detector for I/O Pair 4
    //                      bit0 output of phase detector for I/O Pair 5 (only on cmdctla
    // FUBs) 
    //         
    // 
    // Bits[21:8], RO_V, default = 0x0
    //
    UINTX xoverphasedet : 14;
    //
    // Offset added to PiCode. Obtained via xover calibration such that ClkPi aligns
    // with grid clock when PiCode=0. 
    // 
    // Bits[27:22], RW_L, default = 0x0
    //
    UINTX trainingoffset2 : 6;
    //
    // Spare
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare1 : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDTRAINING_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CMDS_DDRIOHI_REG                0x00000C30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdOutputEnable
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdoutputensel : 12;
    //
    // Select CompCode between cmd or ctl
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX selectcompcode : 1;
    //
    // Imode coef
    // 
    // Bits[15:13], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CmdHighCtlSelfRefresh
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX eqlowpowerdisable : 1;
    //
    // 1: Center Tap Termination for DDR3; 0: Vddq Termination for DDR4/VMSE
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Static leg enable
    // 
    // Bits[23:22], RW_L, default = 0x3
    //
    UINTX dqstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[25:24], RW_L, default = 0x3
    //
    UINTX odtstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xtalklowpower : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //  
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled  
    //             for deemphasized, and so on.
    //         
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX txeq : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING2_CMDS_DDRIOHI_REG                0x00000C34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode3 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay3 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel3 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode4 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay4 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel4 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode5 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay5 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel5 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING2_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING3_CMDS_DDRIOHI_REG                0x00000C38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode6 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay6 : 2;
    //
    // Selects the Xover Phase
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel6 : 1;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING3_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLMISRMASK_CMDS_DDRIOHI_REG                 0x00000C3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Masking out Miser during VMSE
    // 
    // Bits[11:0], RW_LB, default = 0x0
    //
    UINTX ctlmisrmask : 12;
    //
    // First PiClk Sweep bit
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect0qnnnh : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect1qnnnh : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX ddraciomodeselqnnnh : 1;
    //
    // Spare
    // 
    // Bits[31:15], RW_LB, default = 0x0
    //
    UINTX spare : 17;
  } Bits;
  UINTX Data;
} DDRCRCTLMISRMASK_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CMDS_DDRIOHI_REG               0x00000C40
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description:
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode
    //         PanicVoltage     21:18  Unsigned integer controlling the voltage error
    // on VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP1_CMDS_DDRIOHI_REG                    0x00000C44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VT Comp Values
    // 
    // Bits[4:0], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[14:5], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[24:15], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
    //
    // Spare
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP1_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL1_CMDS_DDRIOHI_REG              0x00000C48
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  BDX-specific extended control signal. 
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl : 8;
    //
    // spare.
    // 
    // Bits[31:8], RW_L, default = 0x0
    //
    UINTX spare : 24;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL1_CMDS_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CTL_DDRIOHI_REG                      0x00000E00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value, Normally updated by Comp FSM via CompBus. can be overriden via message
    // channel if periodical retrain is disabled. 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value, Normally updated by Comp FSM via CompBus. can be overriden via
    // message channel if periodical retrain is disabled. 
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value, Normally updated by Comp FSM via CompBus. can be overriden
    // via message channel if periodical retrain is disabled. 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // not used
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CTL_DDRIOHI_REG                0x00000E04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value, Signed. per fub, added onto FSM value.
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Enable DDRT Parity in CMDCTL
    // 
    // Bits[28:17], RW_L, default = 0x0
    //
    UINTX ddrcmdctlrx_en : 12;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING_CTL_DDRIOHI_REG                  0x00000E08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode0 : 6;
    //
    // Cmd Pi Logic Delay - add 1 qclk cycle delay.
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay0 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel0 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode1 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay1 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel1 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode2 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay2 : 2;
    //
    // not used
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel2 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CTL_DDRIOHI_REG                  0x00000E0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Phased based xtalk cancellation is enabled, set this to delay cmd to maintain
    // constant Tcwl. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX ddrphasextalkenableqnnnh : 1;
    //
    // Enable Visa debug bus LCB for CMD fub
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // enable PiRef clock divider in xover
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX pirefclkdivenable : 1;
    //
    // Xover Select between grid-PiRef and PiRef-PiN
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX xoveropmode : 1;
    //
    // On weak lock exit, controls how long the feedback to the phase detector is masked:
    // {0: 1 qclk (required for delayline latency), 1: 2 qclk, 2: 3 qclk, 3: 4 qclk}
    // 
    // Bits[5:4], RW_L, default = 0x0
    //
    UINTX dllmask : 2;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Forces the CMD transmitter on, overriding any power downs
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Forces on all PI enables and the LCB enables in the AFE fubs.  Does not force
    // on D0 PI enable or override weaklock mode. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX intclkon : 1;
    //
    // not used 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX repclkon : 1;
    //
    // Controls IO Loopback.  Ctl[1] enables IOLB mode and Ctl[0] controls if this is
    // a Setup(0) or Hold(1) test 
    // 
    // Bits[11:10], RW_L, default = 0x0
    //
    UINTX iolbctl : 2;
    //
    // Forces the driver in ODT mode, where both the pullup and pulldown are enabled.
    //  Used for Rstray testing 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX odtmode : 1;
    //
    // not used
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX cmdtxeq : 2;
    //
    // Controls the number of segments enabled during the early warning weak drive: {0:
    // All Enabled, 1: Enable Seg[4], 2: Enable Seg[4:3], 3: Enable Seg[4:2]} 
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX earlyweakdrive : 2;
    //
    // not used
    //         
    // 
    // Bits[18:17], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
    //
    // not used
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // IOLB Vref Control.  2s compliment encoding from 1/3 Vdd to 2/3 Vdd with step size
    // of Vdd/192 (7.8mV) 
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX rxvref : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX halflsbbit : 1;
    //
    //  Vref Disable
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vrefdisable : 1;
    //
    // Ddr4 Mode Enable, set to 1 in CMD2 (Func:5.Addr:C00 and Func:7.Addr:C00) fub to
    // bypass extra delay on parity bit 
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddr4modeenable : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS2_CTL_DDRIOHI_REG                 0x00000E10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdCtl RxVoSel or RxVocPassGateEn  for CmdCtl Receiver
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdrxvocpassgateen : 12;
    //
    // FNV Cmd Power Down
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX fnvcrcmdpowerdown : 1;
    //
    // FNV Cr Cmd Is CKE
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX fnvcrcmdiscke : 6;
    //
    // FNV Cmd Sample Enable
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX fnvcmdsampleen : 1;
    //
    // FNV DDR/PI Bypass Enable
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX fnvddrcrdllpibypassen : 1;
    //
    // Enable finer vref resolution in ddr4
    //         
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // BDX change : This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[22:22], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
    //
    // CmdRxBiasSel for Cmd Receiver
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX cmdrxbiassel : 1;
    //
    // ForceCmdBiason for Cmd Receiver
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX forcecmdbiason : 1;
    //
    // bypass ddrcmdctl xover for FNV
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX fnvcmdcrxoverbypassen : 1;
    //
    // CmdCtl Buffer CtleCapEn
    // 
    // Bits[27:26], RW_L, default = 0x0
    //
    UINTX cmdctlecapen : 2;
    //
    // CmdCtl Buffer CtleResEn
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX cmdctleresen : 2;
    //
    // RxOffsetCodeUngate or CmdRxOffsetCtlEnable for CmdCtl Rx buffer
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX rxoffsetcodeungate : 1;
    //
    // SaOffsetTrainTxOn or CmdSaOffsetTrain for Cmd buf
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS2_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMP_CTL_DDRIOHI_REG                      0x00000E14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Value
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Tco Comp Value
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Rcomp Drv Up Value
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Rcomp Drv Dn Value
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // LevelShift Comp Value
    // 
    // Bits[27:25], RW_L, default = 0x0
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMP_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMPOFFSET_CTL_DDRIOHI_REG                0x00000E18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Scomp Offset Value
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX scompoffset : 5;
    //
    // Tco Comp Offset Value
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX tcocompoffset : 4;
    //
    // Rcomp Drv Up Offset Value
    // 
    // Bits[12:9], RW_L, default = 0x0
    //
    UINTX rcompdrvupoffset : 4;
    //
    // Rcomp Drv Dn Offset Value
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX rcompdrvdownoffset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdctlbufsel : 6;
    //
    // Is the Direction (RX/TX Valid)
    // 
    // Bits[24:24], RW_L, default = 0x1
    //
    UINTX iodirectionvalid : 1;
    //
    // CmdBuf or CtlBuf Selection 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMPOFFSET_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CTL_DDRIOHI_REG                 0x00000E1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Drive strength enable for CmdBuf/CtlBuf.
    // 
    // Bits[4:0], RW_L, default = 0x1F
    //
    UINTX bufdrvsegen : 5;
    //
    // control the DdrVrefSelDQQnnnH pin on the ddrvrefint generator
    // 
    // Bits[5:5], RW_L, default = 0x1
    //
    UINTX cmdvrefpgen : 1;
    //
    // OdtStrength 
    // 
    // Bits[6:6], RW_L, default = 0x1
    //
    UINTX odtstrength : 1;
    //
    // spare1
    // 
    // Bits[8:7], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Invert DAlign 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX divby2alignctl : 1;
    //
    // select qclk for cmdxover instead of Dclk 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX divby2disable : 1;
    //
    // ODTDis for Cmd and Ctl buf
    // 
    // Bits[22:11], RW_L, default = 0x0
    //
    UINTX odten : 12;
    //
    // CmdRefClk
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX cmdrefpiclkdelay : 6;
    //
    // Spare
    // 
    // Bits[31:29], RW_L, default = 0x0
    //
    UINTX spare : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLRANKSUSED_CTL_DDRIOHI_REG                 0x00000E20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables output buffers for ctlbufpair 0 to ctlbufpair6 , PI clocks and output
    // datapaths for this rank 
    // 
    // Bits[5:0], RW_L, default = 0x3F
    //
    UINTX ranken : 6;
    //
    // Spare
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX spare : 6;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // used to compensate the GCN skew. The GCN skew information should be
    //           extracted by reading and analyzing the final Rcomp code value. The target
    // spec 
    //           is to categorize the GCN skew in 3 process condition (mainly slow, fast,
    // typical). 
    //           (one example can be just reading the 2 MLS bit of Rcomp code and determine
    // if the 
    //           GCN is slow, fast or typical). The gcncomp is used for CTLE.
    //           11: gcn in slow corner
    //           10: gcn in typical corner
    //           01: gcn in fast corner
    //         
    // 
    // Bits[14:13], RW_L, default = 0x2
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Imode bias DFx leg control
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // Imode bias control
    // 
    // Bits[16:16], RW_L, default = 0x0
    //
    UINTX imodebiashighcm : 1;
    //
    // Rx bias Sel
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // CmdRxEqQnnnL for RX CmdCtl Buf 
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX cmdrxeqqnnnl : 3;
    //
    // spare
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // CmdRxBiasCtl for RX biasgen 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasctl : 3;
    //
    // CmdPcasBiasClosedLoopEnQnnnH for RX biasgen 
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX cmdpcasbiasclosedloopen : 1;
    //
    // DdrCmdRxBiasFoldedLegTrim for RX biasgen 
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX ddrcmdrxbiasfoldedlegtrim : 2;
    //
    // spare1
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare2 : 2;
  } Bits;
  UINTX Data;
} DDRCRCTLRANKSUSED_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADC_CTL_DDRIOHI_REG                   0x00000E24
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADC_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDACIOLB_CTL_DDRIOHI_REG                    0x00000E28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACIO Enable
    // The MISR Logic Enable control bit is a master switch that enables the clock to
    // all of the logic  
    // and circuits that are specific to the command/control ACIO loopback feature. The
    // MISR Logic Enable bit  
    // must be set to one whenever the loopback/MISR logic needs to be used. It should
    // be set to zero otherwise,  
    // so that clock power is not wasted.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX acioen : 1;
    //
    // ACIO MISR Clear
    // The MISR Clear control bit resets the entire shift register to all zero. 
    // The reset is triggered by the zero-to-one transition of the MISR Clear bit, 
    // and after the clear operation is done, the MISR Operation Done bit is set to one.
    //         
    // 
    // Bits[1:1], RW_V, default = 0x0
    //
    UINTX acioclear : 1;
    //
    // ACIO MISR Auto Start
    // The MISR Auto Start control bit arms the control logic to start signature accumulation
    // when it detects  
    // the first non-zero value on the trigger lane. Once the signature collection has
    // been started,  
    // the MISR Auto Start bit is automatically cleared, but the MISR Operation Done
    // bit is set. 
    //         
    // 
    // Bits[2:2], RW_V, default = 0x0
    //
    UINTX acioautostart : 1;
    //
    // ACIO MISR Manual Start
    // The MISR Manual Start bit is a control bit that starts signature collection immediately.
    //  
    // In this case, the control logic does not consider the state of the trigger lane.
    // Signature collection is triggered exclusively by the zero-to-one transition of
    // the MISR Manual Start bit.  
    // Once signature collection is started, the MISR Manual Start bit is automatically
    // cleared,  
    // but the MISR Operation Done bit is set.
    //         
    // 
    // Bits[3:3], RW_V, default = 0x0
    //
    UINTX aciomanustart : 1;
    //
    // ACIO MISR Busy indication
    // The MISR Busy bit indicates that signature collection is running. 
    // It is set when the signature collection timer starts and cleared when the timer
    // stops. 
    //         
    // 
    // Bits[4:4], RO_V, default = 0x0
    //
    UINTX aciomisrbusy : 1;
    //
    // ACIO MISR Operation Done indication
    // The MISR Operation Done bit is set to one whenever a clear, start or shift operation
    // has occurred.  
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[5:5], RW1C, default = 0x0
    //
    UINTX aciomisropdone : 1;
    //
    // ACIO MISR Collection Done indication
    // The MISR Collection Done bit is set to one whenever a signature collection 
    // phase finishes, that is when the signature collection timer stops. 
    // Software will need to clear this bit (write one to clear).
    //         
    // 
    // Bits[6:6], RW1C, default = 0x0
    //
    UINTX aciomisrcollectdone : 1;
    //
    // Spare0
    //         
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX spare0 : 1;
    //
    // ACIOData Parallel Out
    // The MISR Data Out bit is a read-only bit that's essentially one bit in the MISR's
    // shift  
    // (or rotate) chain. Software can read out a signature by reading the MISR Data
    // Out bit  
    // after each of a series of one-bit shift operations using the MISR Shift control
    // bit 
    //         
    // 
    // Bits[19:8], RO_V, default = 0x0
    //
    UINTX aciodata : 12;
    //
    // Spare1
    //         
    // 
    // Bits[28:20], RW_L, default = 0x0
    //
    UINTX spare1 : 9;
    //
    // First PiClk Sweep bit
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ddrsweepselect0 : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddrsweepselect1 : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX ddraciomodesel : 1;
  } Bits;
  UINTX Data;
} DDRCRCMDACIOLB_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDTRAINING_CTL_DDRIOHI_REG                  0x00000E2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained PiCode Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX trainingoffset : 6;
    //
    // Spare
    //         
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX spare0 : 2;
    //
    // bits13:6 unused
    //                      bit5 output of phase detector for I/O Pair 0
    //                      bit4 output of phase detector for I/O Pair 1
    //                      bit3 output of phase detector for I/O Pair 2
    //                      bit2 output of phase detector for I/O Pair 3
    //                      bit1 output of phase detector for I/O Pair 4
    //                      bit0 output of phase detector for I/O Pair 5 (only on cmdctla
    // FUBs) 
    //         
    // 
    // Bits[21:8], RO_V, default = 0x0
    //
    UINTX xoverphasedet : 14;
    //
    // Offset added to PiCode. Obtained via xover calibration such that ClkPi aligns
    // with grid clock when PiCode=0. 
    // 
    // Bits[27:22], RW_L, default = 0x0
    //
    UINTX trainingoffset2 : 6;
    //
    // Spare
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare1 : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDTRAINING_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CTL_DDRIOHI_REG                 0x00000E30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CmdOutputEnable
    // 
    // Bits[11:0], RW_L, default = 0x0
    //
    UINTX cmdoutputensel : 12;
    //
    // Select CompCode between cmd or ctl
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX selectcompcode : 1;
    //
    // Imode coef
    // 
    // Bits[15:13], RW_L, default = 0x0
    //
    UINTX spare1 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CmdHighCtlSelfRefresh
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX eqlowpowerdisable : 1;
    //
    // 1: Center Tap Termination for DDR3; 0: Vddq Termination for DDR4/VMSE
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Static leg enable
    // 
    // Bits[23:22], RW_L, default = 0x3
    //
    UINTX dqstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[25:24], RW_L, default = 0x3
    //
    UINTX odtstatdflt : 2;
    //
    // Static leg enable
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xtalklowpower : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //  
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled  
    //             for deemphasized, and so on.
    //         
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX txeq : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING2_CTL_DDRIOHI_REG                 0x00000E34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode3 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay3 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel3 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX cmdpicode4 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay4 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[17:17], RW_L, default = 0x0
    //
    UINTX xoversel4 : 1;
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX cmdpicode5 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay5 : 2;
    //
    // Selects the Xover Phase
    //         
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX xoversel5 : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare : 5;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING2_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDPICODING3_CTL_DDRIOHI_REG                 0x00000E38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Cmd Pi Code
    //                      [5:0] - Pi setting with [5] being the PiMSB sel
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX cmdpicode6 : 6;
    //
    // Cmd Pi Logic Delay
    // 
    // Bits[7:6], RW_L, default = 0x0
    //
    UINTX cmdpilogicdelay6 : 2;
    //
    // Selects the Xover Phase
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX xoversel6 : 1;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DDRCRCMDPICODING3_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCTLMISRMASK_CTL_DDRIOHI_REG                  0x00000E3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Masking out Miser during VMSE
    // 
    // Bits[11:0], RW_LB, default = 0x0
    //
    UINTX ctlmisrmask : 12;
    //
    // First PiClk Sweep bit
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect0qnnnh : 1;
    //
    // Second PiClk Sweep bit
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX ddrsweepselect1qnnnh : 1;
    //
    // DdrACIOModeSel
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX ddraciomodeselqnnnh : 1;
    //
    // Spare
    // 
    // Bits[31:15], RW_LB, default = 0x0
    //
    UINTX spare : 17;
  } Bits;
  UINTX Data;
} DDRCRCTLMISRMASK_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CTL_DDRIOHI_REG                0x00000E40
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description:
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode
    //         PanicVoltage     21:18  Unsigned integer controlling the voltage error
    // on VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP1_CTL_DDRIOHI_REG                     0x00000E44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VT Comp Values
    // 
    // Bits[4:0], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[14:5], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[24:15], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
    //
    // Spare
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP1_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL1_CTL_DDRIOHI_REG               0x00000E48
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  BDX-specific extended control signal. 
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl : 8;
    //
    // spare.
    // 
    // Bits[31:8], RW_L, default = 0x0
    //
    UINTX spare : 24;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL1_CTL_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_6_DDRIOHI_REG                     0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_6_DDRIOHI_REG                     0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_6_DDRIOHI_REG                     0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_6_DDRIOHI_REG                     0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_6_DDRIOHI_REG                     0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_6_DDRIOHI_REG                     0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_6_DDRIOHI_REG                     0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_6_DDRIOHI_REG                     0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_6_DDRIOHI_REG                     0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_6_DDRIOHI_REG                     0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_6_DDRIOHI_REG                     0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_6_DDRIOHI_REG                     0x0000022C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_6_DDRIOHI_REG                     0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_6_DDRIOHI_REG                     0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_6_DDRIOHI_REG                     0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_6_DDRIOHI_REG                     0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_6_DDRIOHI_REG                     0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_6_DDRIOHI_REG                     0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_6_DDRIOHI_REG                     0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_6_DDRIOHI_REG                     0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_6_DDRIOHI_REG                     0x00000250
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_6_DDRIOHI_REG                     0x00000254
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_6_DDRIOHI_REG                     0x00000258
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_6_DDRIOHI_REG                     0x0000025C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_6_DDRIOHI_REG                     0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_6_DDRIOHI_REG                     0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_6_DDRIOHI_REG                     0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_6_DDRIOHI_REG                     0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_6_DDRIOHI_REG                     0x00000270
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_6_DDRIOHI_REG                     0x00000274
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_6_DDRIOHI_REG                     0x00000278
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_6_DDRIOHI_REG                     0x0000027C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_6_DDRIOHI_REG                     0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_6_DDRIOHI_REG                     0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_6_DDRIOHI_REG                     0x00000288
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_6_DDRIOHI_REG                     0x0000028C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_6_DDRIOHI_REG                     0x00000290
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_6_DDRIOHI_REG                     0x00000294
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_6_DDRIOHI_REG                     0x00000298
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_6_DDRIOHI_REG                     0x0000029C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_6_DDRIOHI_REG                           0x000002A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_6_DDRIOHI_REG                        0x000002A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_6_DDRIOHI_REG                 0x000002A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_6_DDRIOHI_REG                      0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_6_DDRIOHI_REG                        0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_6_DDRIOHI_REG                         0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_6_DDRIOHI_REG                         0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_6_DDRIOHI_REG                   0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_6_DDRIOHI_REG                    0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_6_DDRIOHI_REG                        0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_6_DDRIOHI_REG                      0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_6_DDRIOHI_REG                      0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_6_DDRIOHI_REG                      0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_6_DDRIOHI_REG                      0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_6_DDRIOHI_REG                0x000002F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_6_DDRIOHI_REG                   0x000002FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_6_DDRIOHI_REG                     0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_6_DDRIOHI_REG                     0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_6_DDRIOHI_REG                     0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_6_DDRIOHI_REG                     0x0000030C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_6_DDRIOHI_REG                     0x00000310
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_6_DDRIOHI_REG                     0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_6_DDRIOHI_REG                     0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_6_DDRIOHI_REG                     0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_6_DDRIOHI_REG                     0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_6_DDRIOHI_REG                     0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_6_DDRIOHI_REG                     0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_6_DDRIOHI_REG                     0x0000032C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_6_DDRIOHI_REG                     0x00000330
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_6_DDRIOHI_REG                     0x00000334
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_6_DDRIOHI_REG                     0x00000338
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_6_DDRIOHI_REG                     0x0000033C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_6_DDRIOHI_REG                     0x00000340
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_6_DDRIOHI_REG                     0x00000344
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_6_DDRIOHI_REG                     0x00000348
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_6_DDRIOHI_REG                     0x0000034C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_6_DDRIOHI_REG                     0x00000350
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_6_DDRIOHI_REG                     0x00000354
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_6_DDRIOHI_REG                     0x00000358
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_6_DDRIOHI_REG                     0x0000035C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_6_DDRIOHI_REG                     0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_6_DDRIOHI_REG                     0x00000364
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_6_DDRIOHI_REG                     0x00000368
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_6_DDRIOHI_REG                     0x0000036C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_6_DDRIOHI_REG                     0x00000370
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_6_DDRIOHI_REG                     0x00000374
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_6_DDRIOHI_REG                     0x00000378
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_6_DDRIOHI_REG                     0x0000037C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_6_DDRIOHI_REG                     0x00000380
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_6_DDRIOHI_REG                     0x00000384
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_6_DDRIOHI_REG                     0x00000388
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_6_DDRIOHI_REG                     0x0000038C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_6_DDRIOHI_REG                     0x00000390
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_6_DDRIOHI_REG                     0x00000394
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_6_DDRIOHI_REG                     0x00000398
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_6_DDRIOHI_REG                     0x0000039C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_6_DDRIOHI_REG                           0x000003A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_6_DDRIOHI_REG                        0x000003A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_6_DDRIOHI_REG                 0x000003A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_6_DDRIOHI_REG                      0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_6_DDRIOHI_REG                        0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_6_DDRIOHI_REG                         0x000003D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_6_DDRIOHI_REG                         0x000003D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_6_DDRIOHI_REG                   0x000003DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_6_DDRIOHI_REG                    0x000003E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_6_DDRIOHI_REG                        0x000003E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_6_DDRIOHI_REG                      0x000003E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_6_DDRIOHI_REG                      0x000003EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_6_DDRIOHI_REG                      0x000003F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_6_DDRIOHI_REG                      0x000003F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_6_DDRIOHI_REG                0x000003F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_6_DDRIOHI_REG                   0x000003FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_6_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_7_DDRIOHI_REG                     0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_7_DDRIOHI_REG                     0x00000404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_7_DDRIOHI_REG                     0x00000408
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_7_DDRIOHI_REG                     0x0000040C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_7_DDRIOHI_REG                     0x00000410
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_7_DDRIOHI_REG                     0x00000414
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_7_DDRIOHI_REG                     0x00000418
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_7_DDRIOHI_REG                     0x0000041C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_7_DDRIOHI_REG                     0x00000420
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_7_DDRIOHI_REG                     0x00000424
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_7_DDRIOHI_REG                     0x00000428
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_7_DDRIOHI_REG                     0x0000042C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_7_DDRIOHI_REG                     0x00000430
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_7_DDRIOHI_REG                     0x00000434
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_7_DDRIOHI_REG                     0x00000438
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_7_DDRIOHI_REG                     0x0000043C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_7_DDRIOHI_REG                     0x00000440
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_7_DDRIOHI_REG                     0x00000444
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_7_DDRIOHI_REG                     0x00000448
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_7_DDRIOHI_REG                     0x0000044C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_7_DDRIOHI_REG                     0x00000450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_7_DDRIOHI_REG                     0x00000454
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_7_DDRIOHI_REG                     0x00000458
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_7_DDRIOHI_REG                     0x0000045C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_7_DDRIOHI_REG                     0x00000460
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_7_DDRIOHI_REG                     0x00000464
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_7_DDRIOHI_REG                     0x00000468
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_7_DDRIOHI_REG                     0x0000046C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_7_DDRIOHI_REG                     0x00000470
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_7_DDRIOHI_REG                     0x00000474
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_7_DDRIOHI_REG                     0x00000478
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_7_DDRIOHI_REG                     0x0000047C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_7_DDRIOHI_REG                     0x00000480
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_7_DDRIOHI_REG                     0x00000484
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_7_DDRIOHI_REG                     0x00000488
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_7_DDRIOHI_REG                     0x0000048C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_7_DDRIOHI_REG                     0x00000490
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_7_DDRIOHI_REG                     0x00000494
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_7_DDRIOHI_REG                     0x00000498
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_7_DDRIOHI_REG                     0x0000049C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_7_DDRIOHI_REG                           0x000004A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_7_DDRIOHI_REG                        0x000004A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_7_DDRIOHI_REG                 0x000004A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_7_DDRIOHI_REG                      0x000004CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_7_DDRIOHI_REG                        0x000004D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_7_DDRIOHI_REG                         0x000004D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_7_DDRIOHI_REG                         0x000004D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_7_DDRIOHI_REG                   0x000004DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_7_DDRIOHI_REG                    0x000004E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_7_DDRIOHI_REG                        0x000004E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_7_DDRIOHI_REG                      0x000004E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_7_DDRIOHI_REG                      0x000004EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_7_DDRIOHI_REG                      0x000004F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_7_DDRIOHI_REG                      0x000004F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_7_DDRIOHI_REG                0x000004F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_7_DDRIOHI_REG                   0x000004FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_7_DDRIOHI_REG                     0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_7_DDRIOHI_REG                     0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_7_DDRIOHI_REG                     0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_7_DDRIOHI_REG                     0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_7_DDRIOHI_REG                     0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_7_DDRIOHI_REG                     0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_7_DDRIOHI_REG                     0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_7_DDRIOHI_REG                     0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_7_DDRIOHI_REG                     0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_7_DDRIOHI_REG                     0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_7_DDRIOHI_REG                     0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_7_DDRIOHI_REG                     0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_7_DDRIOHI_REG                     0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_7_DDRIOHI_REG                     0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_7_DDRIOHI_REG                     0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_7_DDRIOHI_REG                     0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_7_DDRIOHI_REG                     0x00000540
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_7_DDRIOHI_REG                     0x00000544
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_7_DDRIOHI_REG                     0x00000548
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_7_DDRIOHI_REG                     0x0000054C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_7_DDRIOHI_REG                     0x00000550
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_7_DDRIOHI_REG                     0x00000554
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_7_DDRIOHI_REG                     0x00000558
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_7_DDRIOHI_REG                     0x0000055C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_7_DDRIOHI_REG                     0x00000560
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_7_DDRIOHI_REG                     0x00000564
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_7_DDRIOHI_REG                     0x00000568
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_7_DDRIOHI_REG                     0x0000056C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_7_DDRIOHI_REG                     0x00000570
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_7_DDRIOHI_REG                     0x00000574
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_7_DDRIOHI_REG                     0x00000578
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_7_DDRIOHI_REG                     0x0000057C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_7_DDRIOHI_REG                     0x00000580
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_7_DDRIOHI_REG                     0x00000584
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_7_DDRIOHI_REG                     0x00000588
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_7_DDRIOHI_REG                     0x0000058C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_7_DDRIOHI_REG                     0x00000590
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_7_DDRIOHI_REG                     0x00000594
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_7_DDRIOHI_REG                     0x00000598
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_7_DDRIOHI_REG                     0x0000059C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_7_DDRIOHI_REG                           0x000005A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_7_DDRIOHI_REG                        0x000005A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_7_DDRIOHI_REG                 0x000005A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_7_DDRIOHI_REG                      0x000005CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_7_DDRIOHI_REG                        0x000005D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_7_DDRIOHI_REG                         0x000005D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_7_DDRIOHI_REG                         0x000005D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_7_DDRIOHI_REG                   0x000005DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_7_DDRIOHI_REG                    0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_7_DDRIOHI_REG                        0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_7_DDRIOHI_REG                      0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_7_DDRIOHI_REG                      0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_7_DDRIOHI_REG                      0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_7_DDRIOHI_REG                      0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_7_DDRIOHI_REG                0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_7_DDRIOHI_REG                   0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_7_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CKE_FIELD_DDRIOHI_REG          0x00000840
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields 
    // 
    // Bits[5:0], RW, default = 0x1E
    //
    UINTX vtargetgd : 6;
    //
    // New register created  for new fields 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX fastintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[9:8], RW, default = 0x2
    //
    UINTX slowintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[12:10], RW, default = 0x0
    //
    UINTX divctrl : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX cropenloopgd : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[15:14], RW, default = 0x2
    //
    UINTX maxerrgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX panicengdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX closeloopcr : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[21:18], RW, default = 0x5
    //
    UINTX codepanic : 4;
    //
    // New register created  for new fields 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINTX gainboostgdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX viewselgdl : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CKE_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROL_CTL_FIELD_DDRIOHI_REG          0x00000E40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields 
    // 
    // Bits[5:0], RW, default = 0x1E
    //
    UINTX vtargetgd : 6;
    //
    // New register created  for new fields 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX fastintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[9:8], RW, default = 0x2
    //
    UINTX slowintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[12:10], RW, default = 0x0
    //
    UINTX divctrl : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX cropenloopgd : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[15:14], RW, default = 0x2
    //
    UINTX maxerrgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX panicengdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX closeloopcr : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[21:18], RW, default = 0x5
    //
    UINTX codepanic : 4;
    //
    // New register created  for new fields 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINTX gainboostgdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX viewselgdl : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROL_CTL_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CMDN_DATA_DDRIOHI_REG                0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CMDN_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_CMDS_DATA_DDRIOHI_REG                0x00000C00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_CMDS_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CTL_DATA_DDRIOHI_REG             0x00000E0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CTL_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CKE_DATA_DDRIOHI_REG             0x0000080C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CKE_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CMDN_DATA_DDRIOHI_REG            0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CMDN_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS_CMDS_DATA_DDRIOHI_REG            0x00000C0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS_CMDS_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCLKCONTROLS_DATA_DDRIOHI_REG                 0x00000A10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCLKCONTROLS_DATA_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CMDN_FIELD_DDRIOHI_REG          0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // New register created  for new fields: OdtEn[0]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX odten_bit0 : 1;
    //
    // New register created  for new fields: OdtEn[1]
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX odten_bit1 : 1;
    //
    // New register created  for new fields: OdtEn[2]
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX odten_bit2 : 1;
    //
    // New register created  for new fields: OdtEn[3]
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX odten_bit3 : 1;
    //
    // New register created  for new fields: OdtEn[4]
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX odten_bit4 : 1;
    //
    // New register created  for new fields: OdtEn[5]
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX odten_bit5 : 1;
    //
    // New register created  for new fields: OdtEn[6]
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX odten_bit6 : 1;
    //
    // New register created  for new fields: OdtEn[7]
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX odten_bit7 : 1;
    //
    // New register created  for new fields: OdtEn[8]
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX odten_bit8 : 1;
    //
    // New register created  for new fields: OdtEn[9]
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX odten_bit9 : 1;
    //
    // New register created  for new fields: OdtEn[10]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX odten_bit10 : 1;
    //
    // New register created  for new fields: OdtEn[11]
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX odten_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CMDN_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS3_CMDS_FIELD_DDRIOHI_REG          0x00000C1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // New register created  for new fields: OdtEn[0]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX odten_bit0 : 1;
    //
    // New register created  for new fields: OdtEn[1]
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX odten_bit1 : 1;
    //
    // New register created  for new fields: OdtEn[2]
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX odten_bit2 : 1;
    //
    // New register created  for new fields: OdtEn[3]
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX odten_bit3 : 1;
    //
    // New register created  for new fields: OdtEn[4]
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX odten_bit4 : 1;
    //
    // New register created  for new fields: OdtEn[5]
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX odten_bit5 : 1;
    //
    // New register created  for new fields: OdtEn[6]
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX odten_bit6 : 1;
    //
    // New register created  for new fields: OdtEn[7]
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX odten_bit7 : 1;
    //
    // New register created  for new fields: OdtEn[8]
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX odten_bit8 : 1;
    //
    // New register created  for new fields: OdtEn[9]
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX odten_bit9 : 1;
    //
    // New register created  for new fields: OdtEn[10]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX odten_bit10 : 1;
    //
    // New register created  for new fields: OdtEn[11]
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX odten_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS3_CMDS_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CMDN_FIELD_DDRIOHI_REG         0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[0]
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit0 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[1]
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit1 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[2]
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit2 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[3]
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit3 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[4]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit4 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[5]
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit5 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[6]
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit6 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[7]
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit7 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[8]
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit8 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[9]
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit9 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[10]
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit10 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[11]
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CMDN_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMPOFFSET_CMDS_FIELD_DDRIOHI_REG         0x00000C04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[0]
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit0 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[1]
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit1 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[2]
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit2 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[3]
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit3 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[4]
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit4 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[5]
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit5 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[6]
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit6 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[7]
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit7 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[8]
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit8 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[9]
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit9 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[10]
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit10 : 1;
    //
    // New register created  for new fields: DDRCMDCTLRX_EN[11]
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX ddrcmdctlrx_en_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMPOFFSET_CMDS_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CMDN_FIELD_DDRIOHI_REG          0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields: OutputEnable[0]
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit0 : 1;
    //
    // New register created  for new fields: OutputEnable[1]
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit1 : 1;
    //
    // New register created  for new fields: OutputEnable[2]
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit2 : 1;
    //
    // New register created  for new fields: OutputEnable[3]
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit3 : 1;
    //
    // New register created  for new fields: OutputEnable[4]
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit4 : 1;
    //
    // New register created  for new fields: OutputEnable[5]
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit5 : 1;
    //
    // New register created  for new fields: OutputEnable[6]
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit6 : 1;
    //
    // New register created  for new fields: OutputEnable[7]
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit7 : 1;
    //
    // New register created  for new fields: OutputEnable[8]
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit8 : 1;
    //
    // New register created  for new fields: OutputEnable[9]
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit9 : 1;
    //
    // New register created  for new fields: OutputEnable[10]
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit10 : 1;
    //
    // New register created  for new fields: OutputEnable[11]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CMDN_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CMDS_FIELD_DDRIOHI_REG          0x00000C30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields: OutputEnable[0]
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit0 : 1;
    //
    // New register created  for new fields: OutputEnable[1]
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit1 : 1;
    //
    // New register created  for new fields: OutputEnable[2]
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit2 : 1;
    //
    // New register created  for new fields: OutputEnable[3]
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit3 : 1;
    //
    // New register created  for new fields: OutputEnable[4]
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit4 : 1;
    //
    // New register created  for new fields: OutputEnable[5]
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit5 : 1;
    //
    // New register created  for new fields: OutputEnable[6]
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit6 : 1;
    //
    // New register created  for new fields: OutputEnable[7]
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit7 : 1;
    //
    // New register created  for new fields: OutputEnable[8]
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit8 : 1;
    //
    // New register created  for new fields: OutputEnable[9]
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit9 : 1;
    //
    // New register created  for new fields: OutputEnable[10]
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit10 : 1;
    //
    // New register created  for new fields: OutputEnable[11]
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit11 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CMDS_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCONTROLS1_CKE_FIELD_DDRIOHI_REG           0x00000830
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields: OutputEnable[0]
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit0 : 1;
    //
    // New register created  for new fields: OutputEnable[1]
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit1 : 1;
    //
    // New register created  for new fields: OutputEnable[2]
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit2 : 1;
    //
    // New register created  for new fields: OutputEnable[3]
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit3 : 1;
    //
    // New register created  for new fields: OutputEnable[4]
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit4 : 1;
    //
    // New register created  for new fields: OutputEnable[5]
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit5 : 1;
    //
    // New register created  for new fields: OutputEnable[6]
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit6 : 1;
    //
    // New register created  for new fields: OutputEnable[7]
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit7 : 1;
    //
    // New register created  for new fields: OutputEnable[8]
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit8 : 1;
    //
    // New register created  for new fields: OutputEnable[9]
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX cmdoutputensel_bit9 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} DDRCRCMDCONTROLS1_CKE_FIELD_DDRIOHI_STRUCT;
#endif // ASM_INC


#endif // _DDRIOHI_H_
